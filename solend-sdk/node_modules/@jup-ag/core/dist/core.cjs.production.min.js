"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@solana/spl-token"),t=require("@solana/web3.js"),n=require("@project-serum/serum"),o=require("@saberhq/stableswap-sdk"),i=require("jsbi"),r=require("@project-serum/anchor"),a=require("@project-serum/anchor/dist/cjs/utils/pubkey"),s=require("bn.js"),u=require("@solana/buffer-layout"),c=require("js-sha256"),m=require("@jup-ag/math"),d=require("decimal.js"),l=require("cross-fetch"),p=require("@mercurial-finance/optimist"),g=require("@jup-ag/crema-sdk"),h=require("@jup-ag/lifinity-sdk"),f=require("@jup-ag/whirlpool-sdk"),A=require("@jup-ag/cykura-sdk"),S=require("@jup-ag/cykura-sdk-core"),k=require("@project-serum/anchor/dist/cjs/utils/bytes");function y(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function M(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var o=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,o.get?o:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,t}var w=y(i),P=M(r),T=y(s),v=y(d),b=y(l),B=[{wrapper:"2B5Qedoo95Pjpv9xVPw82bbmcGDGCNHroKpzQE2CNHRZ",underlying:"CASHVDm2wsJXfhj6VWxb7GiMdoLc17Du7paH4bNr5woT",underlyingDecimals:6,wrapperUnderlyingTokens:"3YCGgStAV9H7TdPYdBnRP8yoH4Zqdmyt7xo6KB4Wa8xt",mint:"C9xqJe3gMTUDKidZsZ6jJ7tL9zSLimDUKVpgUbLZnNbi",decimals:9},{wrapper:"2ffwMLE4dxSv59eYXhfhfuS81kz6gzf6DZjdBxRHZz9A",underlying:"AGFEad2et2ZJif9jaGpdMixQqvW5i81aBdvKe7PHNfz3",underlyingDecimals:6,wrapperUnderlyingTokens:"H5tnZcfHCzHueNnfd6foeBBUUW4g7qXKt6rKzT7wg6oP",mint:"FTT9rBBrYwcHam4qLvkzzzhrsihYMbZ3k6wJbdoahxAt",decimals:9},{wrapper:"3A85wiQg2REhBVxVS1CjDaS333TBNM2g37BbdNGSMheg",underlying:"CDJWUqTcYTVAKXAVXoQZFes5JUFc7owSeq7eMQcDSbo5",underlyingDecimals:8,wrapperUnderlyingTokens:"764FaQrrREvNTpaH2yXyrPZgVBaXA7AXM8vyCaevXitD",mint:"BtX7AfzEJLnU8KQR1AgHrhGH5s2AHUTbfjhUQP8BhPvi",decimals:10},{wrapper:"7hWjnVC6FNkmmgjq88LEnRycrKvxVB1MsJ6FQcrvxe4n",underlying:"9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E",underlyingDecimals:6,wrapperUnderlyingTokens:"B22gDMgN2tNWmvyzhb5tamJKanWcUUUw2zN3h3qjgQg8",mint:"9999j2A8sXUtHtDoQdk528oVzhaKBsXyRGZ67FKGoi7H",decimals:9},{wrapper:"8zooyPZrq2mth917VrHLtNTk6GvAhc2KgdB4DGBXYyke",underlying:"AUrMpCDYYcPuHhyNX8gEEqbmDPFUpBpHrNW3vPeCFn5Z",underlyingDecimals:9,wrapperUnderlyingTokens:"7ZZyhVde6ZmnVMuFnrg3mRPHhvfBixLdEo7RnwxTtpF7",mint:"EY3s4nXTzHDiiysmjvj7zWP6yAX3n4xHmXkJWD1w1tGP",decimals:15},{wrapper:"93qsLbASEG8DmtSB2MEVaa25KvEm2afh5rzbaAJHLi5A",underlying:"7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs",underlyingDecimals:8,wrapperUnderlyingTokens:"4fUL9yLbFZEuG32SaCjWqJXwDTBFNnipteBWxMvvFoC8",mint:"KNVfdSJyq1pRQk9AKKv1g5uyGuk6wpm4WG16Bjuwdma",decimals:9},{wrapper:"ACvLVgR3UKdDB3b1QapsbJsPXaUrBPdJGDfiFnMYMXoz",underlying:"F6v4wfAdJB8D8p77bMXZgYt8TDKsYxLYxH5AFhUkYx9W",underlyingDecimals:6,wrapperUnderlyingTokens:"AvqMJWHsZscPWTAUcj8dZi2ch6XQEHMpiCMprfFovaU",mint:"LUNGEjUXyP48nrC1GYY5o4eTAkwm4RdX8BxFUxWJBLB",decimals:9},{wrapper:"AnKLLfpMcceM6YXtJ9nGxYekVXqfWy8WNsMZXoQTCVQk",underlying:"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",underlyingDecimals:6,wrapperUnderlyingTokens:"77XHXCWYQ76E9Q3uCuz1geTaxsqJZf9RfX5ZY7yyLDYt",mint:"JEFFSQ3s8T3wKsvp4tnRAsUBW7Cqgnf8ukBZC4C8XBm1",decimals:9},{wrapper:"CGxMr5UrTjApBjU656N9NBAsGby4fWs1KgVtueQ8WKt6",underlying:"AGFEad2et2ZJif9jaGpdMixQqvW5i81aBdvKe7PHNfz3",underlyingDecimals:6,wrapperUnderlyingTokens:"7dVPR6jx3hKyNfuHPo3WtWdUpH4eh4Up4rfFhLHZqwy3",mint:"FTT8cGNp3rfTC6c44uPTuEFLqmsVDhjd2BhH65v2uppr",decimals:8},{wrapper:"D231Uoh24bXtUtWN51ZbFAFSBmGT3zuuEAHZNuCmtRjN",underlying:"CDJWUqTcYTVAKXAVXoQZFes5JUFc7owSeq7eMQcDSbo5",underlyingDecimals:8,wrapperUnderlyingTokens:"C39Wq6X98TLcrnYCMkcHQhwUurkQMUdibUCpf2fVBDsm",mint:"FACTQhZBfRzC7A76antnpAoZtiwYmUfdAN8wz7e8rxC5",decimals:9},{wrapper:"EhQqUmkUXXnxmV7yA6PDrQWvLgSd9HkrwdDKk1B5m6Tc",underlying:"CbNYA9n3927uXUukee2Hf4tm3xxkffJPPZvGazc2EAH1",underlyingDecimals:8,wrapperUnderlyingTokens:"8YC5eCS99umbK9K9LnHnTMMjnr7EWg1gam5maNB6uf9d",mint:"EU9aLffrTckFCs16da6CppHy63fAxMPF9ih1erQTuuRt",decimals:9},{wrapper:"EwWpia5t9Twiwdi8ghK8e8JHaf6ShNU9jmoYpvdZhBwC",underlying:"9vMJfxuKxXBoEa7rM12mYLMwTacLMLDJqHozw96WQL8i",underlyingDecimals:6,wrapperUnderlyingTokens:"9YB1zRL4ETuQFG8ZK1yD4GHBVDmH81EzwuSj75zdnKhK",mint:"UST8SCn7jrqsq51odVLqcmvnC658HkqrKrPL3w2hHQ7",decimals:8},{wrapper:"F9TsAsh5RirU3LqyTJECLQEGXnF4RQT7ckvexCP1KNTu",underlying:"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",underlyingDecimals:6,wrapperUnderlyingTokens:"BSTjdztBrsptuxfz9JHS31Wc9CknpLeL1wqZjeVs1Ths",mint:"AEUT5uFm1D575FVCoQd5Yq891FJEqkncZUbBFoFcAhTV",decimals:9},{wrapper:"FCgoT8RpsopdM5QT6AB98NUfUnDnu7y865MFpRx93JrS",underlying:"EzfgjvkSwthhgHaceR3LnKXUoRkP6NUhfghdaHAj1tUv",underlyingDecimals:8,wrapperUnderlyingTokens:"5yugfArBAUZJJBUCRWPuiLyi6CWp1f67H9xgg3hcgSkx",mint:"FTT9GrHBVHvDeUTgLU8FxVJouGqg9uiWGmmjETdm32Sx",decimals:9},{wrapper:"FDGtFWVhEb1zxnaW2FzogeGDxLoAV7Cu9XdNYPEVwqt",underlying:"8wv2KAykQstNAj2oW6AHANGBiFKVFhvMiyyzzjhkmGvE",underlyingDecimals:6,wrapperUnderlyingTokens:"4R6PmC8BJcPDBsEMGpXpLCnFFkUZhEgZy6pMNtc2LqA4",mint:"KUANeD8EQvwpT1W7QZDtDqctLEh2FfSTy5pThE9CogT",decimals:9},{wrapper:"FPuYMuodknZuQKHA8Wp4PBbp52Qu8nK2oAuwedp2WfM3",underlying:"9vMJfxuKxXBoEa7rM12mYLMwTacLMLDJqHozw96WQL8i",underlyingDecimals:6,wrapperUnderlyingTokens:"GxpyQZi5VkZDSq5TUycMau11sCkQkVCa8xYhBgiPMsyK",mint:"UST98bfV6EASdTFQrRwCBczpehdMFwYCUdLT5tEbhpW",decimals:9},{wrapper:"Ffxi5TSpFV9NeV5KyNDCC7fWnFoFd2bDcL1eViSAE2M2",underlying:"CASHVDm2wsJXfhj6VWxb7GiMdoLc17Du7paH4bNr5woT",underlyingDecimals:6,wrapperUnderlyingTokens:"5s2et753hMXV945U3p5uz6RQqMkZGCPEjKjNPdUcCLLF",mint:"CASHedBw9NfhsLBXq1WNVfueVznx255j8LLTScto3S6s",decimals:8},{wrapper:"G4gRGymKo7MGzGZup12JS39YVCvy8YMM6KY9AmcKi5iw",underlying:"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",underlyingDecimals:6,wrapperUnderlyingTokens:"AQhP39mE4o6BYNwnwYqnz7ZobkPBSLpCg8WvEESq1viZ",mint:"88881Hu2jGMfCs9tMu5Rr7Ah7WBNBuXqde4nR5ZmKYYy",decimals:8},{wrapper:"GiLSv94Wwyd6suH57Fu6HjEKsMxhNGfEwKn9vT22me1p",underlying:"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",underlyingDecimals:6,wrapperUnderlyingTokens:"3cjAWoyDcco8UVCN17keNUNHoyz37ctgDa7G6zkeb81Y",mint:"T8KdT8hDzNhbGx5sjpEUxepnbDB1TZoCa7vtC5JjsMw",decimals:8},{wrapper:"GpkFF2nPfjUcsavgDGscxaUEQ2hYJ563AXXtU8ohiZ7c",underlying:"9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E",underlyingDecimals:6,wrapperUnderlyingTokens:"6hYDFhZ5ddfzoqaAbzRHm8mzG2MQzYQV9295sQHsvNBV",mint:"SBTCB6pWqeDo6zGi9WVRMLCsKsN6JiR1RMUqvLtgSRv",decimals:8},{wrapper:"fvSvtHNFuDHrAN82YEyBApRs3U6vUGCLzKGMuPmCaF8",underlying:"2FPyTwcZLUg1MDrwsyoP4D6s1tM7hAkHYRjkNb5w6Pxk",underlyingDecimals:6,wrapperUnderlyingTokens:"4JWyJ4ZYsQ8uiYue2tTEqcHcFXrDuaQ1rsyjNFfrZm65",mint:"SL819j8K9FuFPL84UepVcFkEZqDUUvVzwDmJjCHySYj",decimals:8}];const I={version:"0.1.0",name:"jupiter",instructions:[{name:"mercurialExchange",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"swapState",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"poolAuthority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"sourceTokenAccount",isMut:!0,isSigner:!1},{name:"destinationTokenAccount",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"saberExchange",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"swapAuthority",isMut:!1,isSigner:!1},{name:"userAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"inputUserAccount",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"outputUserAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"feesTokenAccount",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"saberSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"swapAuthority",isMut:!1,isSigner:!1},{name:"userAuthority",isMut:!1,isSigner:!1},{name:"inputUserAccount",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"outputUserAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"feesTokenAccount",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"saberAddDecimalsDeposit",accounts:[{name:"addDecimalsProgram",isMut:!1,isSigner:!1},{name:"wrapper",isMut:!1,isSigner:!1},{name:"wrapperMint",isMut:!0,isSigner:!1},{name:"wrapperUnderlyingTokens",isMut:!0,isSigner:!1},{name:"owner",isMut:!1,isSigner:!0},{name:"userUnderlyingTokens",isMut:!0,isSigner:!1},{name:"userWrappedTokens",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"saberAddDecimalsWithdraw",accounts:[{name:"addDecimalsProgram",isMut:!1,isSigner:!1},{name:"wrapper",isMut:!1,isSigner:!1},{name:"wrapperMint",isMut:!0,isSigner:!1},{name:"wrapperUnderlyingTokens",isMut:!0,isSigner:!1},{name:"owner",isMut:!1,isSigner:!0},{name:"userUnderlyingTokens",isMut:!0,isSigner:!1},{name:"userWrappedTokens",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"senchaExchange",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!0,isSigner:!1},{name:"userAuthority",isMut:!1,isSigner:!1},{name:"inputUserAccount",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"inputFeesAccount",isMut:!0,isSigner:!1},{name:"outputUserAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"outputFeesAccount",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"serumSwap",accounts:[{name:"market",accounts:[{name:"market",isMut:!0,isSigner:!1},{name:"openOrders",isMut:!0,isSigner:!1},{name:"requestQueue",isMut:!0,isSigner:!1},{name:"eventQueue",isMut:!0,isSigner:!1},{name:"bids",isMut:!0,isSigner:!1},{name:"asks",isMut:!0,isSigner:!1},{name:"coinVault",isMut:!0,isSigner:!1},{name:"pcVault",isMut:!0,isSigner:!1},{name:"vaultSigner",isMut:!1,isSigner:!1}]},{name:"authority",isMut:!1,isSigner:!0},{name:"orderPayerTokenAccount",isMut:!0,isSigner:!1},{name:"coinWallet",isMut:!0,isSigner:!1},{name:"pcWallet",isMut:!0,isSigner:!1},{name:"dexProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"side",type:{defined:"Side"}},{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"tokenSwap",accounts:[{name:"tokenSwapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"source",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"poolFee",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"stepTokenSwap",accounts:[{name:"tokenSwapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"source",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"poolFee",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"cropperTokenSwap",accounts:[{name:"tokenSwapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"swap",isMut:!1,isSigner:!1},{name:"swapState",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"source",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"poolFee",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"raydiumSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"ammId",isMut:!0,isSigner:!1},{name:"ammAuthority",isMut:!1,isSigner:!1},{name:"ammOpenOrders",isMut:!0,isSigner:!1},{name:"ammTargetOrders",isMut:!0,isSigner:!1},{name:"poolCoinTokenAccount",isMut:!0,isSigner:!1},{name:"poolPcTokenAccount",isMut:!0,isSigner:!1},{name:"serumProgramId",isMut:!1,isSigner:!1},{name:"serumMarket",isMut:!0,isSigner:!1},{name:"serumBids",isMut:!0,isSigner:!1},{name:"serumAsks",isMut:!0,isSigner:!1},{name:"serumEventQueue",isMut:!0,isSigner:!1},{name:"serumCoinVaultAccount",isMut:!0,isSigner:!1},{name:"serumPcVaultAccount",isMut:!0,isSigner:!1},{name:"serumVaultSigner",isMut:!1,isSigner:!1},{name:"userSourceTokenAccount",isMut:!0,isSigner:!1},{name:"userDestinationTokenAccount",isMut:!0,isSigner:!1},{name:"userSourceOwner",isMut:!1,isSigner:!0}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"raydiumSwapV2",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"ammId",isMut:!0,isSigner:!1},{name:"ammAuthority",isMut:!1,isSigner:!1},{name:"ammOpenOrders",isMut:!0,isSigner:!1},{name:"poolCoinTokenAccount",isMut:!0,isSigner:!1},{name:"poolPcTokenAccount",isMut:!0,isSigner:!1},{name:"serumProgramId",isMut:!1,isSigner:!1},{name:"serumMarket",isMut:!0,isSigner:!1},{name:"serumBids",isMut:!0,isSigner:!1},{name:"serumAsks",isMut:!0,isSigner:!1},{name:"serumEventQueue",isMut:!0,isSigner:!1},{name:"serumCoinVaultAccount",isMut:!0,isSigner:!1},{name:"serumPcVaultAccount",isMut:!0,isSigner:!1},{name:"serumVaultSigner",isMut:!1,isSigner:!1},{name:"userSourceTokenAccount",isMut:!0,isSigner:!1},{name:"userDestinationTokenAccount",isMut:!0,isSigner:!1},{name:"userSourceOwner",isMut:!1,isSigner:!0}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"aldrinSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"poolSigner",isMut:!1,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"baseTokenVault",isMut:!0,isSigner:!1},{name:"quoteTokenVault",isMut:!0,isSigner:!1},{name:"feePoolTokenAccount",isMut:!0,isSigner:!1},{name:"walletAuthority",isMut:!1,isSigner:!0},{name:"userBaseTokenAccount",isMut:!0,isSigner:!1},{name:"userQuoteTokenAccount",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"side",type:{defined:"Side"}},{name:"platformFeeBps",type:"u8"}]},{name:"aldrinV2Swap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!1,isSigner:!1},{name:"poolSigner",isMut:!1,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"baseTokenVault",isMut:!0,isSigner:!1},{name:"quoteTokenVault",isMut:!0,isSigner:!1},{name:"feePoolTokenAccount",isMut:!0,isSigner:!1},{name:"walletAuthority",isMut:!1,isSigner:!0},{name:"userBaseTokenAccount",isMut:!0,isSigner:!1},{name:"userQuoteTokenAccount",isMut:!0,isSigner:!1},{name:"curve",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"side",type:{defined:"Side"}},{name:"platformFeeBps",type:"u8"}]},{name:"cremaTokenSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"pool",isMut:!0,isSigner:!1},{name:"poolSigner",isMut:!1,isSigner:!1},{name:"userSourceTokenAccount",isMut:!0,isSigner:!1},{name:"userDestinationTokenAccount",isMut:!0,isSigner:!1},{name:"poolSourceTokenAccount",isMut:!0,isSigner:!1},{name:"poolDestinationTokenAccount",isMut:!0,isSigner:!1},{name:"poolTicksAccount",isMut:!0,isSigner:!1},{name:"walletAuthority",isMut:!1,isSigner:!0},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"lifinityTokenSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"amm",isMut:!1,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"sourceInfo",isMut:!0,isSigner:!1},{name:"destinationInfo",isMut:!0,isSigner:!1},{name:"swapSource",isMut:!0,isSigner:!1},{name:"swapDestination",isMut:!0,isSigner:!1},{name:"poolMint",isMut:!0,isSigner:!1},{name:"feeAccount",isMut:!0,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"pythAccount",isMut:!1,isSigner:!1},{name:"pythPcAccount",isMut:!1,isSigner:!1},{name:"configAccount",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"cykuraSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"signer",isMut:!1,isSigner:!0},{name:"factoryState",isMut:!1,isSigner:!1},{name:"poolState",isMut:!0,isSigner:!1},{name:"inputTokenAccount",isMut:!0,isSigner:!1},{name:"outputTokenAccount",isMut:!0,isSigner:!1},{name:"inputVault",isMut:!0,isSigner:!1},{name:"outputVault",isMut:!0,isSigner:!1},{name:"lastObservationState",isMut:!0,isSigner:!1},{name:"coreProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"whirlpoolSwap",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"tokenAuthority",isMut:!1,isSigner:!0},{name:"whirlpool",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountA",isMut:!0,isSigner:!1},{name:"tokenVaultA",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountB",isMut:!0,isSigner:!1},{name:"tokenVaultB",isMut:!0,isSigner:!1},{name:"tickArray0",isMut:!0,isSigner:!1},{name:"tickArray1",isMut:!0,isSigner:!1},{name:"tickArray2",isMut:!0,isSigner:!1},{name:"oracle",isMut:!1,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"aToB",type:"bool"},{name:"platformFeeBps",type:"u8"}]},{name:"whirlpoolSwapExactOutput",accounts:[{name:"swapProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"tokenAuthority",isMut:!1,isSigner:!0},{name:"whirlpool",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountA",isMut:!0,isSigner:!1},{name:"tokenVaultA",isMut:!0,isSigner:!1},{name:"tokenOwnerAccountB",isMut:!0,isSigner:!1},{name:"tokenVaultB",isMut:!0,isSigner:!1},{name:"tickArray0",isMut:!0,isSigner:!1},{name:"tickArray1",isMut:!0,isSigner:!1},{name:"tickArray2",isMut:!0,isSigner:!1},{name:"oracle",isMut:!1,isSigner:!1}],args:[{name:"outAmount",type:"u64"},{name:"maximumInAmount",type:"u64"},{name:"aToB",type:"bool"},{name:"platformFeeBps",type:"u8"}]},{name:"marinadeFinanceDeposit",accounts:[{name:"marinadeFinanceProgram",isMut:!1,isSigner:!1},{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"liqPoolMsolLegAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"transferFrom",isMut:!0,isSigner:!1},{name:"mintTo",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"userWsolTokenAccount",isMut:!0,isSigner:!1},{name:"tempWsolTokenAccount",isMut:!0,isSigner:!1},{name:"userTransferAuthority",isMut:!0,isSigner:!0},{name:"wsolMint",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"marinadeFinanceLiquidUnstake",accounts:[{name:"marinadeFinanceProgram",isMut:!1,isSigner:!1},{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"getMsolFrom",isMut:!0,isSigner:!1},{name:"getMsolFromAuthority",isMut:!1,isSigner:!0},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"userWsolTokenAccount",isMut:!0,isSigner:!1}],args:[{name:"inAmount",type:{option:"u64"}},{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"riskCheckAndFee",accounts:[{name:"tokenLedger",isMut:!0,isSigner:!1},{name:"userDestinationTokenAccount",isMut:!0,isSigner:!1},{name:"userTransferAuthority",isMut:!1,isSigner:!0},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"minimumOutAmount",type:"u64"},{name:"platformFeeBps",type:"u8"}]},{name:"initializeTokenLedger",accounts:[{name:"tokenLedger",isMut:!0,isSigner:!0},{name:"payer",isMut:!0,isSigner:!0},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"setTokenLedger",accounts:[{name:"tokenLedger",isMut:!0,isSigner:!1},{name:"tokenAccount",isMut:!1,isSigner:!1}],args:[]},{name:"createOpenOrders",accounts:[{name:"openOrders",isMut:!0,isSigner:!1},{name:"payer",isMut:!0,isSigner:!0},{name:"dexProgram",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"market",isMut:!1,isSigner:!1}],args:[]}],accounts:[{name:"tokenLedger",type:{kind:"struct",fields:[{name:"tokenAccount",type:"publicKey"},{name:"amount",type:"u64"}]}}],types:[{name:"Swap",type:{kind:"struct",fields:[{name:"tokens",type:"u64"},{name:"minTokens",type:"u64"},{name:"side",type:{defined:"Side"}}]}},{name:"Swap",type:{kind:"struct",fields:[{name:"tokens",type:"u64"},{name:"minTokens",type:"u64"},{name:"side",type:{defined:"Side"}}]}},{name:"Swap",type:{kind:"struct",fields:[{name:"amountIn",type:"u64"},{name:"minimumAmountOut",type:"u64"}]}},{name:"Deposit",type:{kind:"struct",fields:[{name:"lamports",type:"u64"}]}},{name:"LiquidUnstake",type:{kind:"struct",fields:[{name:"msolAmount",type:"u64"}]}},{name:"Swap",type:{kind:"struct",fields:[{name:"amount",type:"u64"},{name:"otherAmountThreshold",type:"u64"},{name:"sqrtPriceLimit",type:"u128"},{name:"amountSpecifiedIsInput",type:"bool"},{name:"aToB",type:"bool"}]}},{name:"SwapInstrution",type:{kind:"enum",variants:[{name:"Swap",fields:[{defined:"Swap"}]}]}},{name:"Side",type:{kind:"enum",variants:[{name:"Bid"},{name:"Ask"}]}},{name:"Direction",type:{kind:"enum",variants:[{name:"LeftToRight"},{name:"RightToLeft"}]}}],errors:[{code:6e3,name:"SlippageToleranceExceeded",msg:"Slippage tolerance exceeded"},{code:6001,name:"InvalidTokenLedger",msg:"Invalid token ledger"},{code:6002,name:"MissingTokenLedger",msg:"Missing token ledger"},{code:6003,name:"MissingMercurialExchangeTokenAccount",msg:"Missing mercurial exchange token account"},{code:6004,name:"LedgerTokenAccountDoesNotMatch",msg:"Ledger token account does not match"},{code:6005,name:"MissingPlatformFeeAccount",msg:"Missing platform fee account"},{code:6006,name:"InvalidCalculation",msg:"Invalid calculation"}]},F=new t.PublicKey("So11111111111111111111111111111111111111112"),O=new t.PublicKey("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),D=new t.PublicKey("DESVgJVGajEgKGXhb6XmqDHGz3VjdgP7rEVESBgxmroY"),E={devnet:"https://api.jup.ag/api/markets/cache/devnet","mainnet-beta":"https://cache.jup.ag/markets?v=3",testnet:"https://api.jup.ag/api/markets/cache/devnet"},L=new t.PublicKey("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),R=new t.PublicKey("AMM55ShdkoGRB5jVYPjWziwk8m5MpwyDgsMWHaMSQWH6"),q=new t.PublicKey("CURVGoZn8zycx6FXwwevgBTB2gVvdbGTEpvMJDbgs2t4"),x=new t.PublicKey("DecZY86MU5Gj7kppfUCEmd4LbXXuyZH1yHaP2NTqdiZB"),N=new t.PublicKey("CTMAxxk34HjKWxQ3QLZK1HpaLXmBveao3ESePXbiyfzh"),K=new t.PublicKey("SCHAtsf8mbjyjiv4LkhLKutTf6JnZAbdJKFkXQNMFHZ"),C=new t.PublicKey("EewxydAPCCVuNEyrVN68PuSYdQ7wKn27V9Gjeoi8dy3S"),U=new t.PublicKey("6MLxLqiXaaSUpkgMnWDTuejNZEz3kE7k2woyHGVFw319"),_=new t.PublicKey("BUX7s2ef2htTGb2KKoPHWkmzxPj4nTWMWRgs5CSbQxf9"),V=new t.PublicKey("MERLuDFBMmsHnsBPZw2sDQZHvXFMwp8EdjudcU2HKky"),W=new t.PublicKey("whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc"),G=new t.PublicKey("cysPXAjehMpVKUapzbMCCnpFxUFFryEWEaLgnb9NrR8"),z=new t.PublicKey("DBsMwKfeoUHhxMi9x6wd2AsT12UwUCssjNbUzu1aKgqj"),j=new t.PublicKey("MarBmsSgKXdrN1egZf5sqe1TMai9K1rChYNDJgjq7aD"),Q=new t.PublicKey("Dooar9JkhdZ7J3LHN3A7YCuoGRUggXhQaG4kijfLGU2j"),Z=new t.PublicKey("9W959DqEETiGZocYWCQPaJ6sBmUzgfxXfqGeTEdp3aQP"),H=new t.PublicKey("SSwpMgqNDsyV7mAgN9ady4bDVu5ySjmmXejXvy2vLt1"),Y=new t.PublicKey("PSwapMdSai8tjrEXcxFeQth87xC4rRsa4VA5mhGhXkP"),X=new t.PublicKey("SSwapUtytfBdBn1b9NUGG6foMVPtcWgpRU32HToDUZr"),J=["StepAscQoEioFxxWGnh2sLBDFp9d8rvKz2Yp39iDpyT","DubwWZNWiNGMMeeQHPnMATNj77YZPZSAz2WVR5WjLJqz"],$=Object.freeze({AlreadyInUse:{code:1,name:"AlreadyInUsed",msg:"Account already In Used"},InsufficientSOL:{code:1,name:"InsufficientSOL",msg:"Insufficient SOL"},TransactionNotConfirmed:{code:7e3,name:"TransactionNotConfirmed",msg:"Transaction was not confirmed"},BalancesNotExtractedProperly:{code:7001,name:"BalancesNotExtractedProperly",msg:"Balances cannot be extracted properly"},...I.errors.reduce(((e,t)=>({...e,[t.name]:t})),{})});class ee extends u.Layout{constructor(e){const t=u.blob(32);super(t.span,e),this.layout=void 0,this.layout=t}getSpan(e,t){return this.layout.getSpan(e,t)}decode(e,n){return new t.PublicKey(this.layout.decode(e,n))}encode(e,t,n){return this.layout.encode(e.toBuffer(),t,n)}}const te=e=>new ee(e);class ne extends u.Layout{constructor(e=8,t){const n=u.blob(e);super(n.span,t),this.layout=void 0,this.layout=n}getSpan(e,t){return this.layout.getSpan(e,t)}decode(t,n){return new e.u64(this.layout.decode(t,n),10,"le")}encode(e,t,n){return this.layout.encode(e.toArrayLike(Buffer,"le",this.layout.span),t,n)}}const oe=e=>new ne(8,e),ie=e=>new ne(16,e);function re(e,n){let o=Buffer.alloc(0);e.forEach((function(e){if(e.length>t.MAX_SEED_LENGTH)throw new TypeError("Max seed length exceeded");var n;o=Buffer.concat([o,(n=e,Buffer.isBuffer(n)?n:n instanceof Uint8Array?Buffer.from(n.buffer,n.byteOffset,n.byteLength):Buffer.from(n))])})),o=Buffer.concat([o,n.toBuffer(),Buffer.from("ProgramDerivedAddress")]);let i=c.sha256(new Uint8Array(o)),r=new T.default(i,16).toArray(void 0,32);return new t.PublicKey(r)}const ae=u.struct([u.u8("version"),u.u8("isInitialized"),u.u8("nonce"),te("ammId"),te("serumProgramId"),te("serumMarket"),te("tokenProgramId"),te("tokenAAccount"),te("tokenBAccount"),te("poolMint"),te("mintA"),te("mintB")]),se=u.struct([u.u8("isInitialized"),te("stateOwner"),te("feeOwner"),oe("initialSupply"),oe("returnFeeNumerator"),oe("fixedFeeNumerator"),oe("feeDenominator"),u.u8("curveType"),u.blob(32,"curveParameters")]),ue=new t.PublicKey("3hsU1VgsBgBgz5jWiqdw9RfGU6TpWdCmdah1oi4kF3Tq"),ce=(e,t)=>{const n=t.owner,o=ae.decode(t.data);return{programId:n,authority:re([e.toBuffer(),Buffer.from([o.nonce])],n),version:o.version,isInitialized:Boolean(o.isInitialized),nonce:o.nonce,ammId:o.ammId,serumProgramId:o.serumProgramId,tokenProgramId:o.tokenProgramId,tokenAAccount:o.tokenAAccount,tokenBAccount:o.tokenBAccount,serumMarket:o.serumMarket,poolMint:o.poolMint,mintA:o.mintA,mintB:o.mintB}},me={Bid:{bid:{}},Ask:{ask:{}}},de=new t.PublicKey("JUP3c2Uh3WA4Ng34tw6kPd2G4C5BB21Xo36Je1s32Ph"),le=new r.Program(I,de,{}),pe=[new t.PublicKey("755CiAfB63jK8DTZSM38ZRBTjf1inGM4QfLJTfpPM9x3"),new t.PublicKey("5ZZ7w2C1c348nQm4zaYgrgb8gfyyqQNzH61zPwGvEQK9"),new t.PublicKey("H4K65yLyYqVsDxgNCVGqK7MqrpKFLZjmqf95ZvmfyVDx"),new t.PublicKey("HE4STzYv5dzw2G374ynt4EYvzuKLG41P2xnNffzpdWnG"),new t.PublicKey("3HmXTbZf6G2oEjN3bPreZmF7YGLbbEXFkgAbVFPaimwU"),new t.PublicKey("CUNMrNvGNh1aWR6cVzAQekdsW2dfacnQicyfvgvrN5ap"),new t.PublicKey("6Q6vMHsUFA7kuwdkG9vm7gByMfk151Z9eMSwE14fHcrG")],ge=pe[Math.floor(Math.random()*pe.length)];function he(t,n,o,i){return{swapProgram:V,swapState:t.ammId,tokenProgram:e.TOKEN_PROGRAM_ID,poolAuthority:t.authority,userTransferAuthority:i,sourceTokenAccount:n,destinationTokenAccount:o}}const[fe]=a.findProgramAddressSync([new Uint8Array(Buffer.from("amm authority".replace("Â "," "),"utf-8"))],L);function Ae(t,n,o,i){if(!t.serumMarketKeys)throw new Error("RaydiumAmm is missing serumMarketKeys");return{swapProgram:L,tokenProgram:e.TOKEN_PROGRAM_ID,ammId:t.ammId,ammAuthority:fe,ammOpenOrders:t.ammOpenOrders,poolCoinTokenAccount:t.poolCoinTokenAccount,poolPcTokenAccount:t.poolPcTokenAccount,serumProgramId:t.serumProgramId,serumMarket:t.serumMarket,serumBids:t.serumMarketKeys.serumBids,serumAsks:t.serumMarketKeys.serumAsks,serumEventQueue:t.serumMarketKeys.serumEventQueue,serumCoinVaultAccount:t.serumMarketKeys.serumCoinVaultAccount,serumPcVaultAccount:t.serumMarketKeys.serumPcVaultAccount,serumVaultSigner:t.serumMarketKeys.serumVaultSigner,userSourceTokenAccount:n,userDestinationTokenAccount:o,userSourceOwner:i}}function Se(n,o,i,r,s,u){const c=a.createProgramAddressSync([n.address.toBuffer(),n.decoded.vaultSignerNonce.toArrayLike(Buffer,"le",8)],n.programId);return{market:{market:n.address,openOrders:o,requestQueue:n.decoded.requestQueue,eventQueue:n.decoded.eventQueue,bids:n.bidsAddress,asks:n.asksAddress,coinVault:n.decoded.baseVault,pcVault:n.decoded.quoteVault,vaultSigner:c},authority:u,orderPayerTokenAccount:i,coinWallet:r,pcWallet:s,dexProgram:n.programId,tokenProgram:e.TOKEN_PROGRAM_ID,rent:t.SYSVAR_RENT_PUBKEY}}function ke({swapLayout:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:o,inAmount:i,minimumOutAmount:r,tokenLedger:a,platformFee:s}){var u;const c=[];for(const t of e.tokenAccounts)c.push({pubkey:t,isSigner:!1,isWritable:!0});return c.push(...Ke(i,a,null==s?void 0:s.feeAccount)),le.instruction.mercurialExchange(i,r,null!==(u=null==s?void 0:s.feeBps)&&void 0!==u?u:0,{accounts:he(e,t,n,o),remainingAccounts:c})}function ye({market:e,sourceMint:t,openOrdersAddress:n,userSourceTokenAccount:o,userDestinationTokenAccount:i,userTransferAuthority:r,inAmount:a,minimumOutAmount:s,tokenLedger:u,platformFee:c,referrer:m}){var d;const{side:l,coinWallet:p,pcWallet:g}=t.equals(e.baseMintAddress)?{side:me.Ask,coinWallet:o,pcWallet:i}:{side:me.Bid,coinWallet:i,pcWallet:o};let h=Ke(a,u,null==c?void 0:c.feeAccount);return m&&h.push({pubkey:m,isSigner:!1,isWritable:!0}),le.instruction.serumSwap(l,a,s,null!==(d=null==c?void 0:c.feeBps)&&void 0!==d?d:0,{accounts:Se(e,n,o,p,g,r),remainingAccounts:h})}function Me({tokenSwapState:t,sourceMint:n,userSourceTokenAccount:o,userDestinationTokenAccount:i,userTransferAuthority:r,inAmount:a,minimumOutAmount:s,tokenLedger:u,platformFee:c,isStep:m}){var d;const[l,p]=n.equals(t.mintA)?[t.tokenAccountA,t.tokenAccountB]:[t.tokenAccountB,t.tokenAccountA];return(m?le.instruction.stepTokenSwap:le.instruction.tokenSwap)(a,s,null!==(d=null==c?void 0:c.feeBps)&&void 0!==d?d:0,{accounts:{tokenSwapProgram:t.programId,tokenProgram:e.TOKEN_PROGRAM_ID,swap:t.address,authority:t.authority,userTransferAuthority:r,source:o,swapSource:l,swapDestination:p,destination:i,poolMint:t.poolToken,poolFee:t.feeAccount},remainingAccounts:Ke(a,u,null==c?void 0:c.feeAccount)})}function we({poolState:t,sourceMint:n,userSourceTokenAccount:o,userDestinationTokenAccount:i,userTransferAuthority:r,inAmount:a,minimumOutAmount:s,tokenLedger:u,platformFee:c}){var m;const[d,l]=n.equals(t.token0Mint)?[t.token0Reserves,t.token1Reserves]:[t.token1Reserves,t.token0Reserves],[p,g]=n.equals(t.token0Mint)?[t.token0Fees,t.token1Fees]:[t.token1Fees,t.token0Fees];return le.instruction.senchaExchange(a,s,null!==(m=null==c?void 0:c.feeBps)&&void 0!==m?m:0,{accounts:{swapProgram:t.programId,tokenProgram:e.TOKEN_PROGRAM_ID,swap:t.ammId,userAuthority:r,inputUserAccount:o,inputTokenAccount:d,inputFeesAccount:p,outputUserAccount:i,outputTokenAccount:l,outputFeesAccount:g},remainingAccounts:Ke(a,u,null==c?void 0:c.feeAccount)})}function Pe({poolState:t,feeAccount:n,sourceMint:o,userSourceTokenAccount:i,userDestinationTokenAccount:r,userTransferAuthority:a,inAmount:s,minimumOutAmount:u,tokenLedger:c,platformFee:m}){var d;const[l,p]=o.equals(t.mintA)?[t.tokenAAccount,t.tokenBAccount]:[t.tokenBAccount,t.tokenAAccount];return le.instruction.cropperTokenSwap(s,u,null!==(d=null==m?void 0:m.feeBps)&&void 0!==d?d:0,{accounts:{tokenSwapProgram:t.programId,tokenProgram:e.TOKEN_PROGRAM_ID,swap:t.ammId,swapState:ue,authority:t.authority,userTransferAuthority:a,source:i,swapSource:l,swapDestination:p,destination:r,poolMint:t.poolMint,poolFee:n},remainingAccounts:Ke(s,c,null==m?void 0:m.feeAccount)})}function Te({raydiumAmm:e,userSourceTokenAccount:t,userDestinationTokenAccount:n,userTransferAuthority:o,inAmount:i,minimumOutAmount:r,tokenLedger:a,platformFee:s}){var u;return le.instruction.raydiumSwapV2(i,r,null!==(u=null==s?void 0:s.feeBps)&&void 0!==u?u:0,{accounts:Ae(e,t,n,o),remainingAccounts:Ke(i,a,null==s?void 0:s.feeAccount)})}function ve({poolState:t,sourceMint:n,userSourceTokenAccount:o,userDestinationTokenAccount:i,userTransferAuthority:r,inAmount:a,minimumOutAmount:s,tokenLedger:u,platformFee:c}){var m;const[d,l,p]=n.equals(t.baseTokenMint)?[me.Ask,o,i]:[me.Bid,i,o];return le.instruction.aldrinSwap(a,s,d,null!==(m=null==c?void 0:c.feeBps)&&void 0!==m?m:0,{accounts:{swapProgram:R,pool:t.address,poolSigner:t.poolSigner,poolMint:t.poolMint,baseTokenVault:t.baseTokenVault,quoteTokenVault:t.quoteTokenVault,feePoolTokenAccount:t.feePoolTokenAccount,walletAuthority:r,userBaseTokenAccount:l,userQuoteTokenAccount:p,tokenProgram:e.TOKEN_PROGRAM_ID},remainingAccounts:Ke(a,u,null==c?void 0:c.feeAccount)})}function be({poolState:t,sourceMint:n,userSourceTokenAccount:o,userDestinationTokenAccount:i,curve:r,userTransferAuthority:a,inAmount:s,minimumOutAmount:u,tokenLedger:c,platformFee:m}){var d;const[l,p,g]=n.equals(t.baseTokenMint)?[me.Ask,o,i]:[me.Bid,i,o];return le.instruction.aldrinV2Swap(s,u,l,null!==(d=null==m?void 0:m.feeBps)&&void 0!==d?d:0,{accounts:{swapProgram:q,pool:t.address,poolSigner:t.poolSigner,poolMint:t.poolMint,baseTokenVault:t.baseTokenVault,quoteTokenVault:t.quoteTokenVault,feePoolTokenAccount:t.feePoolTokenAccount,walletAuthority:a,userBaseTokenAccount:p,userQuoteTokenAccount:g,curve:r,tokenProgram:e.TOKEN_PROGRAM_ID},remainingAccounts:Ke(s,c,null==m?void 0:m.feeAccount)})}function Be({poolState:t,sourceMint:n,userSourceTokenAccount:o,userDestinationTokenAccount:i,userTransferAuthority:r,inAmount:a,minimumOutAmount:s,tokenLedger:u,platformFee:c}){var m;const[d,l]=n.equals(t.mintA)?[t.tokenAAccount,t.tokenBAccount]:[t.tokenBAccount,t.tokenAAccount];return le.instruction.cremaTokenSwap(a,s,null!==(m=null==c?void 0:c.feeBps)&&void 0!==m?m:0,{accounts:{swapProgram:t.programId,pool:t.ammId,poolSigner:t.authority,userSourceTokenAccount:o,userDestinationTokenAccount:i,poolSourceTokenAccount:d,poolDestinationTokenAccount:l,poolTicksAccount:t.ticksKey,walletAuthority:r,tokenProgram:e.TOKEN_PROGRAM_ID},remainingAccounts:Ke(a,u,null==c?void 0:c.feeAccount)})}function Ie(t,n,o,i,r){var a;const s=[];return null!=r&&r.feeAccount&&s.push({pubkey:r.feeAccount,isSigner:!1,isWritable:!0}),le.instruction.riskCheckAndFee(o,null!==(a=null==r?void 0:r.feeBps)&&void 0!==a?a:0,{accounts:{tokenLedger:i,userDestinationTokenAccount:t,userTransferAuthority:n,tokenProgram:e.TOKEN_PROGRAM_ID},remainingAccounts:s})}function Fe(e,t){return le.instruction.setTokenLedger({accounts:{tokenLedger:e,tokenAccount:t}})}function Oe(t,n,o,i,r){const a=n.equals(t.state.tokenA.mint)?t.state.tokenB.adminFeeAccount:t.state.tokenA.adminFeeAccount,[s,u]=n.equals(t.state.tokenA.mint)?[t.state.tokenA.reserve,t.state.tokenB.reserve]:[t.state.tokenB.reserve,t.state.tokenA.reserve];return{swapProgram:t.config.swapProgramID,tokenProgram:e.TOKEN_PROGRAM_ID,swap:t.config.swapAccount,swapAuthority:t.config.authority,userAuthority:r,inputUserAccount:o,inputTokenAccount:s,outputUserAccount:i,outputTokenAccount:u,feesTokenAccount:a}}function De({stableSwap:e,sourceMint:t,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:i,inAmount:r,minimumOutAmount:a,tokenLedger:s,platformFee:u}){var c;const m=Ke(r,s,null==u?void 0:u.feeAccount);return le.instruction.saberSwap(r,a,null!==(c=null==u?void 0:u.feeBps)&&void 0!==c?c:0,{accounts:Oe(e,t,n,o,i),remainingAccounts:m})}function Ee({addDecimals:t,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:i,inAmount:r,minimumOutAmount:a,tokenLedger:s,platformFee:u}){var c;const m=Ke(r,s,null==u?void 0:u.feeAccount);return le.instruction.saberAddDecimalsDeposit(r,a,null!==(c=null==u?void 0:u.feeBps)&&void 0!==c?c:0,{accounts:{addDecimalsProgram:x,wrapper:t.wrapper,wrapperMint:t.mint,wrapperUnderlyingTokens:t.wrapperUnderlyingTokens,owner:i,userUnderlyingTokens:n,userWrappedTokens:o,tokenProgram:e.TOKEN_PROGRAM_ID},remainingAccounts:m})}function Le({addDecimals:t,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:i,inAmount:r,minimumOutAmount:a,tokenLedger:s,platformFee:u}){var c;const m=Ke(r,s,null==u?void 0:u.feeAccount);return le.instruction.saberAddDecimalsWithdraw(r,a,null!==(c=null==u?void 0:u.feeBps)&&void 0!==c?c:0,{accounts:{addDecimalsProgram:x,wrapper:t.wrapper,wrapperMint:t.mint,wrapperUnderlyingTokens:t.wrapperUnderlyingTokens,owner:i,userUnderlyingTokens:o,userWrappedTokens:n,tokenProgram:e.TOKEN_PROGRAM_ID},remainingAccounts:m})}function Re({swapState:t,sourceMint:n,userSourceTokenAccount:o,userDestinationTokenAccount:i,userTransferAuthority:r,inAmount:a,minimumOutAmount:s,tokenLedger:u,platformFee:c}){var m;const[d,l]=n.equals(t.tokenAMint)?[t.poolCoinTokenAccount,t.poolPcTokenAccount]:[t.poolPcTokenAccount,t.poolCoinTokenAccount];return le.instruction.lifinityTokenSwap(a,s,null!==(m=null==c?void 0:c.feeBps)&&void 0!==m?m:0,{accounts:{swapProgram:t.programId,authority:t.authority,amm:t.amm,userTransferAuthority:r,sourceInfo:o,destinationInfo:i,swapSource:d,swapDestination:l,poolMint:t.poolMint,feeAccount:t.feeAccount,tokenProgram:e.TOKEN_PROGRAM_ID,pythAccount:t.pythAccount,pythPcAccount:t.pythPcAccount,configAccount:t.configAccount},remainingAccounts:Ke(a,u,null==c?void 0:c.feeAccount)})}function qe({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:i,inAmount:r,minimumOutAmount:a,tokenLedger:s,platformFee:u}){var c;const m=Ke(r,s,null==u?void 0:u.feeAccount);return le.instruction.cykuraSwap(r,a,null!==(c=null==u?void 0:u.feeBps)&&void 0!==c?c:0,{accounts:{swapProgram:G,signer:i,factoryState:z,poolState:t.poolAddress,inputTokenAccount:n,outputTokenAccount:o,inputVault:t.inputVault,outputVault:t.outputVault,lastObservationState:t.lastObservationState,coreProgram:G,tokenProgram:e.TOKEN_PROGRAM_ID},remainingAccounts:m.concat([...t.swapAccountMetas,{pubkey:t.nextObservationState,isSigner:!1,isWritable:!0}])})}function xe({additionalArgs:n,userSourceTokenAccount:o,userDestinationTokenAccount:i,userTransferAuthority:r,inAmount:s,minimumOutAmount:u,tokenLedger:c,platformFee:m}){var d;const l=r,p=a.findProgramAddressSync([Buffer.from("temp-wsol-token-account"),l.toBuffer()],de)[0],g=a.findProgramAddressSync([Buffer.from("temp-sol-pda"),r.toBuffer()],de)[0];return le.instruction.marinadeFinanceDeposit(s,u,null!==(d=null==m?void 0:m.feeBps)&&void 0!==d?d:0,{accounts:{marinadeFinanceProgram:j,state:n.address,userTransferAuthority:r,msolMint:n.marinadeStateResponse.msolMint,liqPoolSolLegPda:n.liqPoolSolLegPda,liqPoolMsolLeg:n.marinadeStateResponse.liqPool.msolLeg,liqPoolMsolLegAuthority:n.liqPoolMsolLegAuthority,reservePda:n.reservePda,transferFrom:g,mintTo:i,msolMintAuthority:n.msolMintAuthority,systemProgram:t.SystemProgram.programId,tokenProgram:e.TOKEN_PROGRAM_ID,userWsolTokenAccount:o,tempWsolTokenAccount:p,wsolMint:e.NATIVE_MINT,rent:t.SYSVAR_RENT_PUBKEY},remainingAccounts:Ke(s,c,null==m?void 0:m.feeAccount)})}function Ne({additionalArgs:n,userSourceTokenAccount:o,userDestinationTokenAccount:i,userTransferAuthority:r,inAmount:s,minimumOutAmount:u,tokenLedger:c,platformFee:m}){var d;const l=a.findProgramAddressSync([Buffer.from("temp-sol-pda"),r.toBuffer()],de)[0];return le.instruction.marinadeFinanceLiquidUnstake(s,u,null!==(d=null==m?void 0:m.feeBps)&&void 0!==d?d:0,{accounts:{marinadeFinanceProgram:j,state:n.address,msolMint:n.marinadeStateResponse.msolMint,liqPoolSolLegPda:n.liqPoolSolLegPda,liqPoolMsolLeg:n.marinadeStateResponse.liqPool.msolLeg,treasuryMsolAccount:n.marinadeStateResponse.treasuryMsolAccount,getMsolFrom:o,getMsolFromAuthority:r,transferSolTo:l,systemProgram:t.SystemProgram.programId,tokenProgram:e.TOKEN_PROGRAM_ID,userWsolTokenAccount:i},remainingAccounts:Ke(s,c,null==m?void 0:m.feeAccount)})}function Ke(e,t,n){const o=[];return null===e&&o.push({pubkey:t,isSigner:!1,isWritable:!0}),n&&o.push({pubkey:n,isSigner:!1,isWritable:!0}),o}function Ce(){return B.map((e=>{const n={wrapper:new t.PublicKey(e.wrapper),underlying:new t.PublicKey(e.underlying),underlyingDecimals:e.underlyingDecimals,wrapperUnderlyingTokens:new t.PublicKey(e.wrapperUnderlyingTokens),mint:new t.PublicKey(e.mint),decimals:e.decimals};return new _e(new Ue(n))}))}class Ue{constructor(e){this.addDecimals=void 0,this.multiplier=void 0,this.addDecimals=e,this.multiplier=w.default.BigInt(10**(this.addDecimals.decimals-this.addDecimals.underlyingDecimals))}getOutputAmount(e,t){if(this.addDecimals.mint.equals(t))return this.calculateWithdrawOutputAmount(e);if(this.addDecimals.underlying.equals(t))return this.calculateDepositOutputAmount(e);throw new Error(`unknown input token: ${t.toString()}`)}calculateDepositOutputAmount(e){return w.default.multiply(e,this.multiplier)}calculateWithdrawOutputAmount(e){return w.default.divide(e,this.multiplier)}}class _e{constructor(e){this.wrappedToken=void 0,this.id=void 0,this.label="Saber (Decimals)",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.wrappedToken=e,this.id=this.wrappedToken.addDecimals.wrapper.toBase58()}getAccountsForUpdate(){return new Array}update(e){}getQuote({sourceMint:e,amount:t}){return{notEnoughLiquidity:!1,inAmount:t,outAmount:this.wrappedToken.getOutputAmount(t,e),feeAmount:m.ZERO,feeMint:e.toBase58(),feePct:0,priceImpactPct:0}}createSwapInstructions(e){return this.wrappedToken.addDecimals.underlying.equals(e.sourceMint)?[Ee({addDecimals:this.wrappedToken.addDecimals,...e,inAmount:e.amount,minimumOutAmount:e.otherAmountThreshold})]:[Le({addDecimals:this.wrappedToken.addDecimals,...e,inAmount:e.amount,minimumOutAmount:e.otherAmountThreshold})]}get reserveTokenMints(){return[this.wrappedToken.addDecimals.underlying,this.wrappedToken.addDecimals.mint]}}function Ve(e){return e.reduce(((t,n)=>(e.forEach((e=>{n!==e&&t.push([n,e])})),t)),new Array)}function We(e,t){return Array.apply(0,new Array(Math.ceil(e.length/t))).map(((n,o)=>e.slice(o*t,(o+1)*t)))}async function Ge(e,n,o=1e3,i=100){return(await Promise.all(We(n,o).map((async n=>{const o=We(n,i).map((t=>({methodName:"getMultipleAccounts",args:e._buildArgs([t],e.commitment,"base64")})));return e._rpcBatchRequest(o).then((e=>e.reduce(((e,n)=>(n.result.value.forEach((n=>{if(n){const o=n;o.data=Buffer.from(n.data[0],n.data[1]),o.owner=new t.PublicKey(n.owner),e.push(o)}else e.push(null)})),e)),[]))).catch((e=>n.map((()=>null))))})))).flat()}var ze;exports.SwapMode=void 0,(ze=exports.SwapMode||(exports.SwapMode={})).ExactIn="ExactIn",ze.ExactOut="ExactOut";const je=(e,t)=>t.map((t=>{const n=e.get(t.toString());if(!n)throw new Error(`Account info ${t.toBase58()} missing`);return n})),Qe=e=>e.map((e=>w.default.BigInt(e.amount))),Ze=u.struct([u.nu64("status"),u.nu64("nonce"),u.nu64("orderNum"),u.nu64("depth"),u.nu64("coinDecimals"),u.nu64("pcDecimals"),u.nu64("state"),u.nu64("resetFlag"),u.nu64("minSize"),u.nu64("volMaxCutRatio"),u.nu64("amountWaveRatio"),u.nu64("coinLotSize"),u.nu64("pcLotSize"),u.nu64("minPriceMultiplier"),u.nu64("maxPriceMultiplier"),u.nu64("systemDecimalsValue"),u.nu64("minSeparateNumerator"),u.nu64("minSeparateDenominator"),u.nu64("tradeFeeNumerator"),u.nu64("tradeFeeDenominator"),u.nu64("pnlNumerator"),u.nu64("pnlDenominator"),u.nu64("swapFeeNumerator"),u.nu64("swapFeeDenominator"),u.nu64("needTakePnlCoin"),u.nu64("needTakePnlPc"),u.nu64("totalPnlPc"),u.nu64("totalPnlCoin"),ie("poolTotalDepositPc"),ie("poolTotalDepositCoin"),ie("swapCoinInAmount"),ie("swapPcOutAmount"),u.nu64("swapCoin2PcFee"),ie("swapPcInAmount"),ie("swapCoinOutAmount"),u.nu64("swapPc2CoinFee"),te("poolCoinTokenAccount"),te("poolPcTokenAccount"),te("coinMintAddress"),te("pcMintAddress"),te("lpMintAddress"),te("ammOpenOrders"),te("serumMarket"),te("serumProgramId"),te("ammTargetOrders"),te("poolWithdrawQueue"),te("poolTempLpTokenAccount"),te("ammOwner"),te("pnlOwner")]);class He{constructor(e,n,o){this.ammId=void 0,this.id=void 0,this.label="Raydium",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.coinMint=void 0,this.pcMint=void 0,this.status=void 0,this.serumProgramId=void 0,this.serumMarket=void 0,this.ammOpenOrders=void 0,this.ammTargetOrders=void 0,this.poolCoinTokenAccount=void 0,this.poolPcTokenAccount=void 0,this.serumMarketKeys=void 0,this.coinReserve=void 0,this.pcReserve=void 0,this.feePct=void 0,this.calculator=void 0,this.ammId=e,this.id=e.toBase58();const i=Ze.decode(n.data);this.status=i.status,this.coinMint=new t.PublicKey(i.coinMintAddress),this.pcMint=new t.PublicKey(i.pcMintAddress),this.poolCoinTokenAccount=new t.PublicKey(i.poolCoinTokenAccount),this.poolPcTokenAccount=new t.PublicKey(i.poolPcTokenAccount),this.serumProgramId=new t.PublicKey(i.serumProgramId),this.serumMarket=new t.PublicKey(i.serumMarket),this.ammOpenOrders=new t.PublicKey(i.ammOpenOrders),this.ammTargetOrders=new t.PublicKey(i.ammTargetOrders),this.serumMarketKeys=Object.keys(o).reduce(((e,n)=>{if(!o[n])throw new Error(`Could not find ${n} in params`);return e[n]=new t.PublicKey(o[n]),e}),{});const r=i.swapFeeNumerator,a=i.swapFeeDenominator;this.feePct=new v.default(r.toString()).div(a.toString()),this.calculator=new m.TokenSwapConstantProduct(new m.Fraction(w.default.BigInt(r),w.default.BigInt(a)),m.ZERO_FRACTION)}static decodeSerumMarketKeysString(e,t,o){const i=n.Market.getLayout(e).decode(o.data),r=re([t.toBuffer(),i.vaultSignerNonce.toArrayLike(Buffer,"le",8)],e);return{serumBids:i.bids.toBase58(),serumAsks:i.asks.toBase58(),serumEventQueue:i.eventQueue.toBase58(),serumCoinVaultAccount:i.baseVault.toBase58(),serumPcVaultAccount:i.quoteVault.toBase58(),serumVaultSigner:r.toBase58()}}getAccountsForUpdate(){return[this.ammId,this.poolCoinTokenAccount,this.poolPcTokenAccount,this.ammOpenOrders]}update(t){const[o,i,r,a]=je(t,this.getAccountsForUpdate()),[s,u]=[He.tokenAmountAccessor(i),He.tokenAmountAccessor(r)],c=n.OpenOrders.fromAccountInfo(this.ammOpenOrders,a,a.owner),m=Ze.decode(o.data);this.coinReserve=s.add(c.baseTokenTotal).sub(new e.u64(String(m.needTakePnlCoin))),this.pcReserve=u.add(c.quoteTokenTotal).sub(new e.u64(String(m.needTakePnlPc)))}static tokenAmountAccessor(t){return e.u64.fromBuffer(t.data.slice(64,72))}getQuote({sourceMint:e,amount:t}){const{coinReserve:n,pcReserve:o}=this;if(!n||!o)throw new Error("Pool token accounts balances not refreshed or empty");const i=this.coinMint.equals(e)?1:0,r=this.calculator.exchange([w.default.BigInt(n),w.default.BigInt(o)],t,i);return{notEnoughLiquidity:!1,inAmount:t,outAmount:r.expectedOutputAmount,feeAmount:r.fees,feeMint:e.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:r.priceImpact.toNumber()}}createSwapInstructions(e){return[Te({raydiumAmm:this,...e,inAmount:e.amount,minimumOutAmount:e.otherAmountThreshold})]}get reserveTokenMints(){return[this.coinMint,this.pcMint]}}const Ye=["77quYg4MGneUdjgXCunt9GgM1usmrxKY31twEy3WHwcS","5cLrMai1DsLRYc1Nio9qMTicsWtvzjzZfJPXyAoF4t1Z","EERNEEnBqdGzBS8dd46wwNY5F2kwnaCQ3vsq2fNKGogZ","8sFf9TW3KzxLiBXcDcjAxqabEsRroo4EiRr3UG1xbJ9m","2iDSTGhjJEiRxNaLF27CY6daMYPs5hgYrP2REHd5YD62"];function*Xe(e){const t=e.isBids;for(const{key:n,quantity:o}of e.slab.items(t)){const e=w.default.BigInt(n.ushrn(64).toString());yield[e,w.default.BigInt(o.toString())]}}function Je(e,t){const n=e._decoded.baseLotSize;return n.isZero()?new v.default(0):function(e,t){const n=new v.default(e.div(t).toString()),o=e.umod(t),i=o.gcd(t);return n.add(new v.default(o.div(i).toString()).div(new v.default(t.div(i).toString())))}(t.mul(e._decoded.quoteLotSize).mul(e._baseSplTokenMultiplier),n.mul(e._quoteSplTokenMultiplier))}class $e{constructor(e){this.market=void 0,this.id=void 0,this.label="Serum",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this._orderbooks=void 0,this.market=e,this.id=e.address.toBase58()}get orderbooks(){return this._orderbooks}getAccountsForUpdate(){return[this.market.asksAddress,this.market.bidsAddress]}update(e){const[t,o]=je(e,this.getAccountsForUpdate()),i=n.Orderbook.decode(this.market,t.data),r=n.Orderbook.decode(this.market,o.data);this._orderbooks={asks:i,bids:r}}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(!this.orderbooks)throw new Error("Failed to find orderbooks");const o=function({market:e,asks:t,bids:n,fromAmount:o,fromMint:i,toMint:r}){const a=Ye.includes(e.address.toBase58())?1e-4:4e-4;return i.equals(e.quoteMintAddress)&&r.equals(e.baseMintAddress)?function(e,t,n,o){let i=m.ZERO,r=m.ZERO,a=m.ZERO,s=m.ZERO,u=m.ZERO;const c=e.quoteSizeLotsToNumber(new T.default(1));let d=c?w.default.BigInt(new v.default(n.toString()).div(1+o).div(c).floor()):m.ZERO;const l=w.default.BigInt(e.baseSizeLotsToNumber(new T.default(1)).toString());for(let[e,n]of Xe(t)){w.default.equal(r,m.ZERO)&&(r=e),a=e;const t=w.default.multiply(n,l),o=w.default.multiply(n,e);if(u=w.default.add(u,t),w.default.greaterThanOrEqual(o,d)){const t=w.default.divide(d,e);s=w.default.add(s,w.default.multiply(e,t)),i=w.default.add(i,w.default.multiply(l,t)),d=m.ZERO;break}s=w.default.add(s,w.default.multiply(e,n)),i=w.default.add(i,t),d=w.default.subtract(d,o)}const p=new v.default(r.toString()),g=new v.default(a.toString()).sub(p).div(p).toNumber(),h=Je(e,new T.default(r.toString())),f=Je(e,new T.default(s.toString())),A=f.mul(l.toString()).ceil(),S=f.mul(l.toString()).mul(o).ceil();return{side:"buy",notEnoughLiquidity:w.default.lessThanOrEqual(u,i),minimum:{in:w.default.BigInt(h.mul(l.toString()).mul(1+o).ceil()),out:l},inAmount:w.default.BigInt(A.add(S)),outAmount:i,feeAmount:w.default.BigInt(S),priceImpactPct:g,feePct:o}}(e,t,o,a):function(e,t,n,o){let i=w.default.BigInt(0),r=w.default.BigInt(0),a=w.default.BigInt(0),s=w.default.BigInt(0),u=n,c=w.default.BigInt(0);const d=w.default.BigInt(e.baseSizeLotsToNumber(new T.default(1))),l=w.default.BigInt(e.quoteSizeLotsToNumber(new T.default(1)));for(const[e,n]of Xe(t)){w.default.equal(r,m.ZERO)&&(r=e),a=e;const t=w.default.multiply(d,n),o=w.default.multiply(n,w.default.multiply(e,l));if(s=w.default.add(s,t),w.default.greaterThanOrEqual(t,u)){const t=w.default.divide(u,d),n=w.default.multiply(t,e);i=w.default.add(i,w.default.multiply(n,l)),u=w.default.subtract(u,n),c=w.default.add(c,w.default.multiply(t,d));break}i=w.default.add(i,o),u=w.default.subtract(u,t),c=w.default.add(c,t)}let p=new v.default(i.toString()).mul(1-o).floor();const g=Je(e,new T.default(r.toString())),h=Je(e,new T.default(a.toString())),f=g.minus(h).div(g).toNumber();return{side:"sell",notEnoughLiquidity:w.default.greaterThan(w.default.BigInt(n),s),minimum:{in:d,out:w.default.BigInt(g.mul(w.default.toNumber(d)).mul(1-o).floor().toString())},inAmount:c,outAmount:w.default.BigInt(p),feeAmount:w.default.BigInt(new v.default(i.toString()).mul(o).round()),priceImpactPct:f,feePct:o}}(e,n,o,a)}({market:this.market,asks:this.orderbooks.asks,bids:this.orderbooks.bids,fromMint:e,toMint:t,fromAmount:n});return{notEnoughLiquidity:o.notEnoughLiquidity,minInAmount:o.minimum.in,minOutAmount:o.minimum.out,inAmount:o.inAmount,outAmount:o.outAmount,feeAmount:o.feeAmount,feeMint:this.market.quoteMintAddress.toBase58(),feePct:o.feePct,priceImpactPct:o.priceImpactPct}}createSwapInstructions(e){var t;if(!e.openOrdersAddress)throw new Error("Missing open orders");return[ye({market:this.market,openOrdersAddress:e.openOrdersAddress,referrer:null==e||null===(t=e.quoteMintToReferrer)||void 0===t?void 0:t.get(this.market.quoteMintAddress.toBase58()),...e,inAmount:e.amount,minimumOutAmount:e.otherAmountThreshold})]}get reserveTokenMints(){return[this.market.baseMintAddress,this.market.quoteMintAddress]}}$e.getL2=Xe;const et=w.default.BigInt(100);class tt{constructor(e,t,n){this.firstAmm=void 0,this.secondAmm=void 0,this.reserveTokenMints=void 0,this.market=void 0,this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.portion1=0,this.portion2=0,this.firstAmm=e,this.secondAmm=t,this.reserveTokenMints=n,this.market=e instanceof $e?e.market:t instanceof $e?t.market:null}static getAmmIdsFromSplitTradeAmmId(e){const t=e.split("-");return t.length>1?t:[]}static create(e,t){if(!function(e,t){return!(e instanceof $e&&t instanceof He||e instanceof He&&t instanceof $e||e instanceof $e&&t instanceof $e)}(e,t))return;const n=Ve(e.reserveTokenMints),o=Ve(t.reserveTokenMints);for(const i of n)for(const n of o)if(i.every(((e,t)=>e.equals(n[t]))))return new tt(e,t,i)}setPortions(e,t){if(e+t!==100)throw new Error("Split trade portions must sum to 100");this.portion1=e,this.portion2=t}get id(){return`${this.firstAmm.id}-${this.secondAmm.id}`}get label(){return[{label:this.firstAmm.label,portion:this.portion1},{label:this.secondAmm.label,portion:this.portion2}].sort(((e,t)=>t.portion-e.portion)).map((({label:e,portion:t})=>`${e} (${t}%)`)).join(" + ")}getAccountsForUpdate(){return[]}update(e){}getQuote(e){const t=e.sourceMint.toBase58(),n=e.amount;let o={outAmount:m.ZERO,portion:0,firstQuote:void 0,secondQuote:void 0};for(let t=100;t-=5;t>0){const i=w.default.divide(w.default.multiply(n,w.default.BigInt(t)),et),r=w.default.subtract(n,i),a=this.firstAmm.getQuote({...e,amount:i}),s=this.secondAmm.getQuote({...e,amount:r}),u=w.default.add(a.outAmount,s.outAmount);if(w.default.lessThan(u,o.outAmount))break;o={outAmount:u,portion:t,firstQuote:a,secondQuote:s}}if(!o.firstQuote||!o.secondQuote)throw new Error("Unreachable: There was no better solution than getting 0 outAmount");const{outAmount:i,portion:r,firstQuote:a,secondQuote:s}=o,u=r,c=100-u;this.portion1=u,this.portion2=c;let d={amount:a.feeAmount,mint:a.feeMint},l={amount:s.feeAmount,mint:s.feeMint};d.mint!==l.mint&&(d.mint!==t&&(d={amount:w.default.divide(w.default.divide(w.default.multiply(d.amount,w.default.multiply(n,w.default.BigInt(u))),et),o.outAmount),mint:t}),l.mint!==t&&(l={amount:w.default.divide(w.default.divide(w.default.multiply(w.default.multiply(l.amount,n),w.default.BigInt(c)),et),o.outAmount),mint:t}));const p=(u*a.feePct+c*s.feePct)/100,g=(u*a.priceImpactPct+c*s.priceImpactPct)/100;return{notEnoughLiquidity:!1,inAmount:e.amount,outAmount:i,feeAmount:w.default.add(d.amount,l.amount),feeMint:d.mint,feePct:p,priceImpactPct:g}}createSwapInstructions(e){const t=e.amount;if(null===t)throw new Error("Split trade cannot be used with a null inAmount");const n=t.mul(new s.BN(this.portion1)).div(new s.BN(et.toString())),o=t.sub(n);return[...this.firstAmm.createSwapInstructions({...e,amount:n,otherAmountThreshold:new s.BN(0),platformFee:void 0}),...this.secondAmm.createSwapInstructions({...e,amount:o,otherAmountThreshold:new s.BN(0),platformFee:void 0}),Ie(e.userDestinationTokenAccount,e.userTransferAuthority,new s.BN(e.otherAmountThreshold.toString()),e.tokenLedger,e.platformFee)]}}const nt=(e,t)=>!(e.id===t.id||e instanceof _e&&t instanceof _e||e instanceof tt||t instanceof tt);class ot{constructor(e){this.stableSwap=void 0,this.id=void 0,this.label="Saber",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.tokenAccounts=[],this.calculator=void 0,this.stableSwap=e,this.id=e.config.swapAccount.toBase58(),this.calculator=new m.Stable(m.TWO,o.calculateAmpFactor(this.stableSwap.state),[m.ONE,m.ONE],new m.Fraction(this.stableSwap.state.fees.trade.numerator,this.stableSwap.state.fees.trade.denominator))}getAccountsForUpdate(){return[this.stableSwap.state.tokenA.reserve,this.stableSwap.state.tokenB.reserve]}update(e){let t=je(e,this.getAccountsForUpdate());this.tokenAccounts=t.map((e=>{const t=p.deserializeAccount(e.data);if(!t)throw new Error("Invalid token account data");return t}))}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");const i=new v.default(this.stableSwap.state.fees.trade.asFraction.toFixed(4)),[r,a]=this.tokenAccounts[0].mint.equals(e)?[0,1]:[1,0];this.calculator.setAmp(o.calculateAmpFactor(this.stableSwap.state));const s=this.calculator.exchange(Qe(this.tokenAccounts),n,r,a);return{notEnoughLiquidity:!1,inAmount:n,outAmount:s.expectedOutputAmount,feeAmount:s.fees,feeMint:t.toBase58(),feePct:i.toNumber(),priceImpactPct:s.priceImpact.toNumber()}}createSwapInstructions(e){return[De({stableSwap:this.stableSwap,...e,inAmount:e.amount,minimumOutAmount:e.otherAmountThreshold})]}get reserveTokenMints(){return[this.stableSwap.state.tokenA.mint,this.stableSwap.state.tokenB.mint]}}const it=new e.u64(0);class rt{constructor(e,t){this.numerator=void 0,this.denominator=void 0,this.toString=()=>`${this.numerator.toString()}/${this.denominator.toString()}`,this.numerator=e,this.denominator=t}static fromDecimal(e){return rt.fromFraction(e.toDecimalPlaces(1).mul(10).toNumber(),1e3)}static fromFraction(t,n){const o="number"==typeof t?new e.u64(t.toString()):t,i="number"==typeof n?new e.u64(n.toString()):n;return new rt(o,i)}toDecimal(){return this.denominator.eq(it)?new v.default(0):new v.default(this.numerator.toString()).div(new v.default(this.denominator.toString()))}add(t){const n=this.denominator.gcd(t.denominator),o=this.denominator.div(n).mul(t.denominator),i=o.div(this.denominator),r=o.div(t.denominator),a=this.numerator.mul(i),s=t.numerator.mul(r),u=a.add(s);return new rt(new e.u64(u.toString()),new e.u64(o.toString()))}}const at=u.struct([oe("tradeFeeNumerator"),oe("tradeFeeDenominator"),oe("ownerTradeFeeNumerator"),oe("ownerTradeFeeDenominator"),oe("ownerWithdrawFeeNumerator"),oe("ownerWithdrawFeeDenominator")],"fees"),st=[u.blob(8,"padding"),te("lpTokenFreezeVault"),te("poolMint"),te("baseTokenVault"),te("baseTokenMint"),te("quoteTokenVault"),te("quoteTokenMint"),te("poolSigner"),u.u8("poolSignerNonce"),te("authority"),te("initializerAccount"),te("feeBaseAccount"),te("feeQuoteAccount"),te("feePoolTokenAccount"),at],ut=u.struct(st),ct=u.struct([...st,u.u8("curveType"),te("curve")]),mt=u.struct([u.blob(8,"padding"),oe("amp")]);function dt(e,t){const n=!!t.owner.equals(q),o=(n?ct:ut).decode(t.data),i="curveType"in o?{curveType:o.curveType,curve:o.curve}:{};return{isV2:n,address:e,poolMint:o.poolMint,baseTokenVault:o.baseTokenVault,baseTokenMint:o.baseTokenMint,quoteTokenVault:o.quoteTokenVault,quoteTokenMint:o.quoteTokenMint,poolSigner:o.poolSigner,feeBaseAccount:o.feeBaseAccount,feeQuoteAccount:o.feeQuoteAccount,feePoolTokenAccount:o.feePoolTokenAccount,fees:{traderFee:rt.fromFraction(o.fees.tradeFeeNumerator,o.fees.tradeFeeDenominator),ownerFee:rt.fromFraction(o.fees.ownerTradeFeeNumerator,o.fees.ownerTradeFeeDenominator)},...i}}class lt{constructor(e,t,n){if(this.params=void 0,this.id=void 0,this.label="Aldrin",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.poolState=void 0,this.tokenAccounts=[],this.calculator=void 0,this.params=n,this.poolState=dt(e,t),this.id=e.toBase58(),1===this.poolState.curveType){const{amp:e}=this.params;if(!e)throw new Error("Amp is required for a stable curve");this.calculator=new m.TokenSwapStable(w.default.BigInt(e),new m.Fraction(w.default.BigInt(this.poolState.fees.traderFee.numerator.toString()),w.default.BigInt(this.poolState.fees.traderFee.denominator.toString())),new m.Fraction(w.default.BigInt(this.poolState.fees.ownerFee.numerator.toString()),w.default.BigInt(this.poolState.fees.ownerFee.denominator.toString())))}else this.calculator=new m.TokenSwapConstantProduct(new m.Fraction(w.default.BigInt(this.poolState.fees.traderFee.numerator.toString()),w.default.BigInt(this.poolState.fees.traderFee.denominator.toString())),new m.Fraction(w.default.BigInt(this.poolState.fees.ownerFee.numerator.toString()),w.default.BigInt(this.poolState.fees.ownerFee.denominator.toString())))}static decodeStableCurveAmp(e){const{amp:t}=mt.decode(e.data);return 2*t.toNumber()}getAccountsForUpdate(){return[this.poolState.quoteTokenVault,this.poolState.baseTokenVault]}update(e){const t=je(e,this.getAccountsForUpdate());this.tokenAccounts=t.map((e=>{const t=p.deserializeAccount(e.data);if(!t)throw new Error("Invalid token account");return t}))}getQuote({sourceMint:e,amount:t}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");let n=new v.default(this.poolState.fees.traderFee.numerator.toString()).div(this.poolState.fees.traderFee.denominator.toString()).add(new v.default(this.poolState.fees.ownerFee.numerator.toString()).div(this.poolState.fees.ownerFee.denominator.toString()));const o=this.tokenAccounts[0].mint.equals(e)?1:0;let i=this.calculator.exchange(Qe(this.tokenAccounts),t,o);return{notEnoughLiquidity:!1,inAmount:t,outAmount:i.expectedOutputAmount,feeAmount:i.fees,feeMint:e.toBase58(),feePct:n.toNumber(),priceImpactPct:i.priceImpact.toNumber()}}createSwapInstructions(e){if(this.poolState.isV2){if(!this.poolState.curve)throw new Error("Unable to fetch curve account.");return[be({poolState:this.poolState,curve:this.poolState.curve,...e,inAmount:e.amount,minimumOutAmount:e.otherAmountThreshold})]}return[ve({poolState:this.poolState,...e,inAmount:e.amount,minimumOutAmount:e.otherAmountThreshold})]}get reserveTokenMints(){return[this.poolState.baseTokenMint,this.poolState.quoteTokenMint]}}lt.accountInfoToAldrinPoolState=dt;const pt=new Map([[Z.toString(),"Orca"],[H.toString(),"Step"],[Y.toString(),"Penguin"],[X.toString(),"Saros"],[Q.toString(),"Stepn"]]),gt=u.struct([u.u8("version"),u.u8("isInitialized"),u.u8("bumpSeed"),te("tokenProgramId"),te("tokenAccountA"),te("tokenAccountB"),te("tokenPool"),te("mintA"),te("mintB"),te("feeAccount"),oe("tradeFeeNumerator"),oe("tradeFeeDenominator"),oe("ownerTradeFeeNumerator"),oe("ownerTradeFeeDenominator"),oe("ownerWithdrawFeeNumerator"),oe("ownerWithdrawFeeDenominator"),oe("hostFeeNumerator"),oe("hostFeeDenominator"),u.u8("curveType"),u.blob(32,"curveParameters")]),ht=u.struct([u.u8("version"),u.u8("isInitialized"),u.u8("bumpSeed"),te("tokenProgramId"),te("tokenAccountA"),te("tokenAccountB"),te("tokenPool"),te("mintA"),te("mintB"),te("feeAccount"),oe("tradeFeeNumerator"),oe("tradeFeeDenominator"),oe("ownerTradeFeeNumerator"),oe("ownerTradeFeeDenominator"),oe("ownerWithdrawFeeNumerator"),oe("ownerWithdrawFeeDenominator"),u.u8("curveType"),u.blob(32,"curveParameters"),u.u8("poolNonce")]);var ft;!function(e){e[e.ConstantProduct=0]="ConstantProduct",e[e.Stable=2]="Stable"}(ft||(ft={}));class At{constructor(e,n,o){if(this.label=void 0,this.id=void 0,this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.tokenSwapState=void 0,this.curveType=void 0,this.tokenAccounts=[],this.calculator=void 0,this.label=o,this.id=e.toBase58(),this.tokenSwapState=function(e,n){const o=n.owner,i=o.equals(H)?ht.decode(n.data):gt.decode(n.data);if(!i.isInitialized)throw new Error("Invalid token swap state");const r=re([e.toBuffer(),Buffer.from([i.bumpSeed])],o),a=new t.PublicKey(i.tokenPool),s=new t.PublicKey(i.feeAccount),u=new t.PublicKey(i.tokenAccountA),c=new t.PublicKey(i.tokenAccountB),m=new t.PublicKey(i.mintA),d=new t.PublicKey(i.mintB);return{address:e,programId:o,tokenProgramId:new t.PublicKey(i.tokenProgramId),poolToken:a,feeAccount:s,authority:r,tokenAccountA:u,tokenAccountB:c,mintA:m,mintB:d,tradeFeeNumerator:i.tradeFeeNumerator,tradeFeeDenominator:i.tradeFeeDenominator,ownerTradeFeeNumerator:i.ownerTradeFeeNumerator,ownerTradeFeeDenominator:i.ownerTradeFeeDenominator,ownerWithdrawFeeNumerator:i.ownerWithdrawFeeNumerator,ownerWithdrawFeeDenominator:i.ownerWithdrawFeeDenominator,curveType:i.curveType,curveParameters:i.curveParameters,poolNonce:"poolNonce"in i?i.poolNonce:void 0}}(e,n),this.curveType=this.tokenSwapState.curveType,!(this.curveType in ft))throw new Error(`curveType ${this.tokenSwapState.curveType} is not supported`);this.calculator=this.tokenSwapState.curveType===ft.ConstantProduct?new m.TokenSwapConstantProduct(new m.Fraction(w.default.BigInt(this.tokenSwapState.tradeFeeNumerator.toString()),w.default.BigInt(this.tokenSwapState.tradeFeeDenominator.toString())),new m.Fraction(w.default.BigInt(this.tokenSwapState.ownerTradeFeeNumerator.toString()),w.default.BigInt(this.tokenSwapState.ownerTradeFeeDenominator.toString()))):new m.TokenSwapStable(w.default.BigInt(this.tokenSwapState.curveParameters[0]),new m.Fraction(w.default.BigInt(this.tokenSwapState.tradeFeeNumerator.toString()),w.default.BigInt(this.tokenSwapState.tradeFeeDenominator.toString())),new m.Fraction(w.default.BigInt(this.tokenSwapState.ownerTradeFeeNumerator.toString()),w.default.BigInt(this.tokenSwapState.ownerTradeFeeDenominator.toString())))}getAccountsForUpdate(){return[this.tokenSwapState.tokenAccountA,this.tokenSwapState.tokenAccountB]}update(e){const t=je(e,this.getAccountsForUpdate());this.tokenAccounts=t.map((e=>{const t=p.deserializeAccount(e.data);if(!t)throw new Error("Invalid token account");return t}))}getQuote({sourceMint:e,amount:t}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");let n=new v.default(this.tokenSwapState.tradeFeeNumerator.toString()).div(this.tokenSwapState.tradeFeeDenominator.toString()).add(new v.default(this.tokenSwapState.ownerTradeFeeNumerator.toString()).div(this.tokenSwapState.ownerTradeFeeDenominator.toString()));const o=this.tokenAccounts[0].mint.equals(e)?1:0;let i=this.calculator.exchange(Qe(this.tokenAccounts),t,o);return{notEnoughLiquidity:!1,inAmount:t,outAmount:i.expectedOutputAmount,feeAmount:i.fees,feeMint:e.toBase58(),feePct:n.toNumber(),priceImpactPct:i.priceImpact.toNumber()}}createSwapInstructions(e){return[Me({tokenSwapState:this.tokenSwapState,...e,inAmount:e.amount,minimumOutAmount:e.otherAmountThreshold,isStep:this.tokenSwapState.programId.equals(H)})]}get reserveTokenMints(){return[this.tokenSwapState.mintA,this.tokenSwapState.mintB]}}const St=Math.pow(10,10),kt=u.struct([u.u8("version"),u.u8("isInitialized"),u.u8("nonce"),oe("amplificationCoefficient"),oe("feeNumerator"),oe("adminFeeNumerator"),u.u32("tokenAccountsLength"),oe("precisionFactor"),oe("precisionMultiplierA"),oe("precisionMultiplierB"),oe("precisionMultiplierC"),oe("precisionMultiplierD"),te("tokenAccountA"),te("tokenAccountB"),te("tokenAccountC"),te("tokenAccountD")]),yt=(e,t)=>{const n=t.owner,o=kt.decode(t.data),i=o.tokenAccountsLength,r=re([e.toBuffer(),Buffer.from([o.nonce])],n),a=[o.precisionMultiplierA.toNumber(),o.precisionMultiplierB.toNumber(),o.precisionMultiplierC.toNumber(),o.precisionMultiplierD.toNumber()].slice(0,i),s=[o.tokenAccountA,o.tokenAccountB,o.tokenAccountC,o.tokenAccountD].slice(0,i);return{programId:n,authority:r,isInitialized:Boolean(o.isInitialized),nonce:o.nonce,ammId:e,amplificationCoefficient:o.amplificationCoefficient.toNumber(),feeNumerator:o.feeNumerator.toNumber(),tokenAccountsLength:i,precisionFactor:o.precisionFactor.toNumber(),precisionMultipliers:a,tokenAccounts:s}};class Mt{constructor(e,t,n){this.params=void 0,this.id=void 0,this.label="Mercurial",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.swapLayout=void 0,this.tokenAccounts=[],this.calculator=void 0,this.params=n,this.id=e.toBase58(),this.swapLayout=yt(e,t),this.calculator=new m.Stable(w.default.BigInt(this.swapLayout.tokenAccountsLength),w.default.BigInt(this.swapLayout.amplificationCoefficient),this.swapLayout.precisionMultipliers.map((e=>w.default.BigInt(e))),new m.Fraction(w.default.BigInt(this.swapLayout.feeNumerator),w.default.BigInt(St)))}getAccountsForUpdate(){return this.swapLayout.tokenAccounts}update(e){let t=je(e,this.getAccountsForUpdate());this.tokenAccounts=t.map((e=>p.deserializeAccount(e.data))).filter((e=>null!==e))}getQuote({sourceMint:e,destinationMint:t,amount:n}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");const o=this.tokenAccounts.findIndex((t=>t.mint.equals(e))),i=this.tokenAccounts.findIndex((e=>e.mint.equals(t))),r=this.calculator.exchange(Qe(this.tokenAccounts),n,o,i),a=this.swapLayout.feeNumerator/St;return{notEnoughLiquidity:!1,inAmount:n,outAmount:r.expectedOutputAmount,feeAmount:r.fees,feeMint:t.toBase58(),feePct:a,priceImpactPct:r.priceImpact.toNumber()}}createSwapInstructions(e){return[ke({swapLayout:this.swapLayout,...e,inAmount:e.amount,minimumOutAmount:e.otherAmountThreshold})]}get reserveTokenMints(){return this.params.tokenMints.map((e=>new t.PublicKey(e)))}}Mt.decodeSwapLayout=yt;class wt{static async getStateFromStateAccount(e){const t=await e.getAccountInfo(ue);if(!t)throw new Error("State account not found");return(e=>{const t=se.decode(e.data);return{isInitialized:Boolean(t.isInitialized),stateOwner:t.stateOwner,feeOwner:t.feeOwner,initialSupply:t.initialSupply,returnFeeNumerator:t.returnFeeNumerator.toNumber(),fixedFeeNumerator:t.fixedFeeNumerator.toNumber(),feeDenominator:t.feeDenominator.toNumber(),curveType:t.curveType,curveParameters:t.curveParameters}})(t)}constructor(e,n,o){this.id=void 0,this.label="Cropper",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.poolState=void 0,this.tokenAccounts=[],this.calculator=void 0,this.feePct=void 0,this.params=void 0,this.id=e.toBase58(),this.poolState=ce(e,n),this.params={...o,tokenAFeeAccount:new t.PublicKey(o.tokenAFeeAccount),tokenBFeeAccount:new t.PublicKey(o.tokenBFeeAccount)},this.feePct=new v.default(this.params.fixedFeeNumerator).div(this.params.feeDenominator).add(new v.default(this.params.returnFeeNumerator).div(this.params.feeDenominator)),this.calculator=new m.TokenSwapConstantProduct(new m.Fraction(w.default.BigInt(this.params.fixedFeeNumerator),w.default.BigInt(this.params.feeDenominator)),new m.Fraction(w.default.BigInt(this.params.returnFeeNumerator),w.default.BigInt(this.params.feeDenominator)))}getAccountsForUpdate(){return[this.poolState.tokenAAccount,this.poolState.tokenBAccount]}update(e){const t=je(e,this.getAccountsForUpdate());this.tokenAccounts=t.map((e=>{const t=p.deserializeAccount(e.data);if(!t)throw new Error("Invalid token account");return t}))}getQuote({sourceMint:e,amount:t}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");const n=this.tokenAccounts[0].mint.equals(e)?1:0,o=this.calculator.exchange(Qe(this.tokenAccounts),t,n);return{notEnoughLiquidity:!1,inAmount:t,outAmount:o.expectedOutputAmount,feeAmount:o.fees,feeMint:e.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:o.priceImpact.toNumber()}}createSwapInstructions(e){const t=e.sourceMint.equals(this.poolState.mintA)?this.params.tokenAFeeAccount:this.params.tokenBFeeAccount;return[Pe({poolState:this.poolState,feeAccount:t,...e,inAmount:e.amount,minimumOutAmount:e.otherAmountThreshold})]}get reserveTokenMints(){return[this.poolState.mintA,this.poolState.mintB]}}wt.decodePoolState=ce;const Pt=(e,t)=>{const n=t.owner,o=g.TokenSwapAccountLayout.decode(t.data);return{programId:n,authority:re([e.toBuffer(),Buffer.from([o.nonce])],n),version:o.version,isInitialized:Boolean(o.isInitialized),nonce:o.nonce,ammId:e,tokenProgramId:o.tokenProgramId,tokenAAccount:o.swapTokenA,tokenBAccount:o.swapTokenB,ticksKey:o.ticksKey,mintA:o.tokenAMint,mintB:o.tokenBMint,fee:o.fee,currentSqrtPrice:o.currentSqrtPrice,currentLiquity:o.currentLiquity}};class Tt{constructor(e,t){this.id=void 0,this.label="Crema",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.ticks=void 0,this.poolState=void 0,this.poolState=Pt(e,t),this.id=e.toBase58()}getAccountsForUpdate(){return[this.poolState.ammId,this.poolState.ticksKey]}update(e){const[t,n]=je(e,this.getAccountsForUpdate());this.poolState=Pt(this.poolState.ammId,t);const o=g.parseTicksAccount(this.poolState.ticksKey,n);if(!o)throw new Error(`Ticks account invalid: ${this.poolState.ticksKey.toBase58()}`);this.ticks=o.data.ticks}getQuote({sourceMint:e,amount:t}){if(!this.ticks)throw new Error("Unable to fetch accounts for ticks.");if(w.default.equal(t,m.ZERO))return{notEnoughLiquidity:!1,inAmount:t,outAmount:m.ZERO,feeAmount:m.ZERO,feeMint:e.toBase58(),feePct:this.poolState.fee.toNumber(),priceImpactPct:0};const n=this.poolState.mintA.equals(e)?this.preSwapA(new v.default(t.toString())):this.preSwapB(new v.default(t.toString()));if(n.revert)throw new Error("Crema error: insufficient liquidity");return{notEnoughLiquidity:!1,inAmount:t,outAmount:w.default.BigInt(n.amountOut.toString()),feeAmount:w.default.BigInt(n.feeUsed.toString()),feeMint:e.toBase58(),feePct:this.poolState.fee.toNumber(),priceImpactPct:n.impact.toNumber()}}preSwapA(e){if(!this.ticks)throw new Error("Unable to fetch accounts for ticks.");const t=g.calculateSwapA2B(this.ticks,this.poolState.currentSqrtPrice,this.poolState.fee,this.poolState.currentLiquity,e),n=this.poolState.currentSqrtPrice.pow(2),o=t.amountOut.div(t.amountUsed).sub(n).div(n).abs(),i=t.amountUsed.lessThan(e);return{...t,impact:o,revert:i}}preSwapB(e){if(!this.ticks)throw new Error("Unable to fetch accounts for ticks.");const t=g.calculateSwapB2A(this.ticks,this.poolState.currentSqrtPrice,this.poolState.fee,this.poolState.currentLiquity,e),n=this.poolState.currentSqrtPrice.pow(2),o=new v.default(1).div(n),i=t.amountOut.div(t.amountUsed).sub(o).div(o).abs(),r=t.amountUsed.lessThan(e);return{...t,impact:i,revert:r}}createSwapInstructions(e){return[Be({poolState:this.poolState,...e,inAmount:e.amount,minimumOutAmount:e.otherAmountThreshold})]}get reserveTokenMints(){return[this.poolState.mintA,this.poolState.mintB]}}const vt=u.struct([u.blob(8,"discriminator"),te("factory"),u.u8("bump"),oe("index"),te("admin"),te("token0Reserves"),te("token0Mint"),te("token0Fees"),te("token1Reserves"),te("token1Mint"),te("token1Fees"),u.u8("isPaused"),te("poolMint"),oe("tradeFeeKbps"),oe("withdrawFeeKbps"),oe("adminTradeFeeKbps"),oe("adminWithdrawFeeKbps")]);class bt{constructor(e,t){this.id=void 0,this.label="Sencha",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.poolState=void 0,this.calculator=void 0,this.tokenAccounts=[],this.id=e.toBase58(),this.poolState=((e,t)=>{const n=t.owner,o=vt.decode(t.data);return{programId:n,isPaused:Boolean(o.isPaused),bump:o.bump,ammId:e,token0Reserves:o.token0Reserves,token1Reserves:o.token1Reserves,token0Mint:o.token0Mint,token1Mint:o.token1Mint,token0Fees:o.token0Fees,token1Fees:o.token1Fees,poolMint:o.poolMint,tradeFeeKbps:o.tradeFeeKbps.toNumber()}})(e,t),this.calculator=new m.TokenSwapConstantProduct(new m.Fraction(w.default.BigInt(this.poolState.tradeFeeKbps),w.default.BigInt(1e7)),new m.Fraction(m.ZERO,m.ZERO),!1)}get isPaused(){return this.poolState.isPaused}getAccountsForUpdate(){return[this.poolState.token0Reserves,this.poolState.token1Reserves]}update(e){const t=je(e,this.getAccountsForUpdate());this.tokenAccounts=t.map((e=>{const t=p.deserializeAccount(e.data);if(!t)throw new Error("Invalid token account");return t}))}getQuote({sourceMint:e,amount:t}){if(0===this.tokenAccounts.length)throw new Error("Unable to fetch accounts for specified tokens.");const n=this.tokenAccounts[0].mint.equals(e)?1:0;let o=this.calculator.exchange(Qe(this.tokenAccounts),t,n),i=this.poolState.tradeFeeKbps/1e7;return{notEnoughLiquidity:!1,inAmount:t,outAmount:o.expectedOutputAmount,feeAmount:o.fees,feeMint:e.toBase58(),feePct:i,priceImpactPct:o.priceImpact.toNumber()}}createSwapInstructions(e){return[we({poolState:this.poolState,...e,inAmount:e.amount,minimumOutAmount:e.otherAmountThreshold})]}get reserveTokenMints(){return[this.poolState.token0Mint,this.poolState.token1Mint]}}class Bt{constructor(e,t){var n;this.ammAccountInfo=void 0,this.id=void 0,this.label="Lifinity",this.shouldPrefetch=!1,this.exactOutputSupported=!1,this.swapState=void 0,this.poolInfo=void 0,this.accountInfos=[],this.ammAccountInfo=t,this.id=e.toBase58(),this.swapState=((e,t)=>{const n=t.owner,o=h.LIFINITY_AMM_LAYOUT.decode(t.data),[i]=a.findProgramAddressSync([e.toBuffer()],n);return{programId:n,authority:i,amm:e,tokenAMint:o.tokenAMint,tokenBMint:o.tokenBMint,poolMint:o.poolMint,feeAccount:o.poolFeeAccount,pythAccount:o.pythAccount,pythPcAccount:o.pythPcAccount,configAccount:o.configAccount,poolCoinTokenAccount:o.tokenAAccount,poolCoinMint:o.tokenAMint,poolPcTokenAccount:o.tokenBAccount,poolPcMint:o.tokenBMint}})(e,t),this.poolInfo={amm:(n=this.swapState).amm.toBase58(),configAccount:n.configAccount.toBase58(),feeAccount:n.feeAccount.toBase58(),pythAccount:n.pythAccount.toBase58(),pythPcAccount:n.pythPcAccount.toBase58(),poolCoinMint:n.poolCoinMint.toBase58(),poolCoinTokenAccount:n.poolCoinTokenAccount.toBase58(),poolMint:n.poolMint.toBase58(),poolPcTokenAccount:n.poolPcTokenAccount.toBase58(),poolPcMint:n.poolPcMint.toBase58(),poolCoinDecimal:0,poolPcDecimal:0,poolMintDecimal:0,pythBaseDecimal:0}}getAccountsForUpdate(){return[this.swapState.poolCoinTokenAccount,this.swapState.poolPcTokenAccount,this.swapState.configAccount,this.swapState.pythAccount,this.swapState.pythPcAccount]}update(e){this.getAccountsForUpdate().forEach(((t,n)=>{const o=e.get(t.toBase58());o&&(this.accountInfos[n]={publicKey:t,account:o})}))}getQuote({sourceMint:e,amount:t}){if(this.accountInfos.length!==this.getAccountsForUpdate().length)throw new Error("Accounts not loaded");const n=this.swapState.poolCoinMint.equals(e)?h.TradeDirection.AtoB:h.TradeDirection.BtoA,{amm:o,pyth:i,pythPc:r,fees:a,coinBalance:s,pcBalance:u,config:c}=h.getParsedData([{publicKey:this.swapState.amm,account:this.ammAccountInfo},...this.accountInfos],this.poolInfo);if(!i.status.equals(1)||r&&!r.status.equals(1))throw new Error("Pyth accounts are outdated");const m=new v.default(t.toString()),d=h.getCurveAmount(m,i.publishSlot.toNumber(),o,a,s,u,c,i,r,n);return{notEnoughLiquidity:!1,inAmount:t,outAmount:w.default.BigInt(d.amountSwapped.toString()),feeAmount:w.default.BigInt(d.fee.ceil().toString()),feeMint:e.toBase58(),feePct:d.feePercent.toNumber(),priceImpactPct:d.priceImpact.toNumber()}}createSwapInstructions(e){return[Re({swapState:this.swapState,...e,inAmount:e.amount,minimumOutAmount:e.otherAmountThreshold})]}get reserveTokenMints(){return[this.swapState.poolCoinMint,this.swapState.poolPcMint]}}function It(e,t){const n=f.parseWhirlpool(t);if(!n)throw new Error(`Failed to parse whirlpool ${e.toBase58()}`);return n}class Ft{constructor(e,t){this.address=void 0,this.id=void 0,this.label="Orca (Whirlpools)",this.shouldPrefetch=!0,this.exactOutputSupported=!0,this.whirlpoolData=void 0,this.tickArrays=new Map,this.tickPks=void 0,this.oracle=void 0,this.feePct=void 0,this.address=e,this.id=e.toBase58(),this.whirlpoolData=It(e,t.data),this.oracle=a.findProgramAddressSync([Buffer.from("oracle"),e.toBuffer()],W)[0],this.feePct=new v.default(this.whirlpoolData.feeRate).div(1e6),this.tickPks=f.getTickArrayPks(e,this.whirlpoolData)}getAccountsForUpdate(){return[this.address,...this.tickPks]}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Missing ${this.address.toBase58()}`);this.whirlpoolData=It(this.address,t.data),this.tickPks=f.getTickArrayPks(this.address,this.whirlpoolData),this.tickArrays.clear();for(const t of this.tickPks){const n=t.toBase58(),o=e.get(n);if(!o)continue;const i=f.parseTickArray(o.data);if(!i)throw new Error(`Could not parse tick array ${n}`);this.tickArrays.set(n,i)}}getQuote({sourceMint:e,destinationMint:t,amount:n,swapMode:o}){const i=f.getSwapQuote({poolAddress:this.address,whirlpool:this.whirlpoolData,tickArrays:this.tickArrays,tokenMint:o===exports.SwapMode.ExactIn?e:t,tokenAmount:new T.default(n.toString()),isInput:o===exports.SwapMode.ExactIn}),r=w.default.BigInt(i.amountIn.toString()),a=w.default.BigInt(i.amountOut.toString()),s=w.default.BigInt(this.feePct.mul(r.toString()).floor().toString()),u=i.aToB?new v.default(i.amountOut.toString()).div(i.amountIn.toString()):new v.default(i.amountIn.toString()).div(i.amountOut.toString()),c=(m=this.whirlpoolData.sqrtPrice,new v.default(m.toString()).mul(v.default.pow(2,-64))).pow(2);var m;const d=c.minus(u).div(c).abs().toNumber();return{notEnoughLiquidity:!1,inAmount:r,outAmount:a,feeAmount:s,feeMint:e.toBase58(),feePct:this.feePct.toNumber(),priceImpactPct:Number(d)}}createSwapInstructions(t){const n=t.sourceMint.equals(this.whirlpoolData.tokenMintA),o=f.getDefaultSqrtPriceLimit(n),[i,r,a]=f.getTickArrayPublicKeysForSwap(this.whirlpoolData.tickCurrentIndex,o,this.whirlpoolData.tickSpacing,this.address,this.tickArrays,W,n);return[t.swapMode===exports.SwapMode.ExactIn?function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:i,inAmount:r,minimumOutAmount:a,tokenLedger:s,platformFee:u}){var c;const[m,d]=t.aToB?[n,o]:[o,n];return le.instruction.whirlpoolSwap(r,a,t.aToB,null!==(c=null==u?void 0:u.feeBps)&&void 0!==c?c:0,{accounts:{swapProgram:W,tokenProgram:e.TOKEN_PROGRAM_ID,tokenAuthority:i,whirlpool:t.whirlpool,tokenOwnerAccountA:m,tokenVaultA:t.tokenVaultA,tokenOwnerAccountB:d,tokenVaultB:t.tokenVaultB,tickArray0:t.tickArray0,tickArray1:t.tickArray1,tickArray2:t.tickArray2,oracle:t.oracle},remainingAccounts:Ke(r,s,null==u?void 0:u.feeAccount)})}({additionalArgs:{aToB:n,whirlpool:this.address,tickArray0:i,tickArray1:r,tickArray2:a,oracle:this.oracle,...this.whirlpoolData},...t,inAmount:t.amount,minimumOutAmount:t.otherAmountThreshold}):(()=>{if(null===t.amount)throw Error("amount cannot be null with exact output");return function({additionalArgs:t,userSourceTokenAccount:n,userDestinationTokenAccount:o,userTransferAuthority:i,outAmount:r,maximumInAmount:a,tokenLedger:s,platformFee:u}){var c;const[m,d]=t.aToB?[n,o]:[o,n];return le.instruction.whirlpoolSwapExactOutput(r,a,t.aToB,null!==(c=null==u?void 0:u.feeBps)&&void 0!==c?c:0,{accounts:{swapProgram:W,tokenProgram:e.TOKEN_PROGRAM_ID,tokenAuthority:i,whirlpool:t.whirlpool,tokenOwnerAccountA:m,tokenVaultA:t.tokenVaultA,tokenOwnerAccountB:d,tokenVaultB:t.tokenVaultB,tickArray0:t.tickArray0,tickArray1:t.tickArray1,tickArray2:t.tickArray2,oracle:t.oracle},remainingAccounts:Ke(new T.default(0),s,null==u?void 0:u.feeAccount)})}({additionalArgs:{aToB:n,whirlpool:this.address,tickArray0:i,tickArray1:r,tickArray2:a,oracle:this.oracle,...this.whirlpoolData},...t,outAmount:t.amount,maximumInAmount:t.otherAmountThreshold})})()]}get reserveTokenMints(){return[this.whirlpoolData.tokenMintA,this.whirlpoolData.tokenMintB]}}class Ot{constructor(e,t){this.program=void 0,this.pool=void 0,this.bitmapCache=void 0,this.tickCache=void 0,this.accountsToFetch={bitmaps:[],ticks:[]},this.program=e,this.pool=t,this.bitmapCache=new Map,this.tickCache=new Map}async eagerLoadCache(e,t){const n=w.default.toNumber(w.default.divide(w.default.BigInt(e),w.default.BigInt(t))),{wordPos:o}=A.tickPosition(n);try{const e=[],{wordPos:n}=A.tickPosition(Math.floor(A.TickMath.MIN_TICK/t)),{wordPos:a}=A.tickPosition(Math.floor(A.TickMath.MAX_TICK/t)),s=Math.max(o-10,n),u=Math.min(o+10,a);for(let t=s;t<u;t++)e.push(this.getBitmapAddressSync(t));const c=await this.program.account.tickBitmapState.fetchMultiple(e),m=[];for(let n=0;n<u-s;n++){var i;const o=n+s,a=null===(i=c[n])||void 0===i?void 0:i.word,u=a?A.generateBitmapWord(a):new r.BN(0);if(this.bitmapCache.set(o,{address:e[n],word:u}),u&&!u.eqn(0))for(let e=0;e<256;e++)if(u.shrn(e).and(new r.BN(1)).eqn(1)){const n=this.getTickAddressSync(((o<<8)+e)*t);m.push(n)}}const d=await this.program.account.tickState.fetchMultiple(m);for(const e in m){const t=d[e];if(!t)continue;const{tick:n,liquidityNet:o}=t;this.tickCache.set(n,{address:m[e],liquidityNet:w.default.BigInt(o)})}}catch(e){}}lazyLoadAccountsToCache(e,t){const n=w.default.toNumber(w.default.divide(w.default.BigInt(e),w.default.BigInt(t))),{wordPos:o}=A.tickPosition(n),i=[],a=[],{wordPos:s}=A.tickPosition(Math.floor(A.TickMath.MIN_TICK/t)),{wordPos:u}=A.tickPosition(Math.floor(A.TickMath.MAX_TICK/t)),c=Math.max(o-10,s),m=Math.min(o+10,u);for(let e=c;e<m;e++){i.push(this.getBitmapAddressSync(e));const t=this.bitmapCache.get(e);a.push(t)}const d=[];for(let e=0;e<m-c;e++){var l,p;const n=e+c,o=null!==(l=null===(p=a[e])||void 0===p?void 0:p.word)&&void 0!==l?l:new r.BN(0);if(this.bitmapCache.set(n,{address:i[e],word:o}),o&&!o.eqn(0))for(let e=0;e<256;e++)if(o.shrn(e).and(new r.BN(1)).eqn(1)){const o=this.getTickAddressSync(((n<<8)+e)*t);d.push(o)}}return this.accountsToFetch={bitmaps:i,ticks:d},[...i,...d]}getTick(e){let t=this.tickCache.get(e);if(!t)throw new Error("Tick not cached");return{address:t.address,liquidityNet:t.liquidityNet}}async getTickAddress(e){return this.getTickAddressSync(e)}getTickAddressSync(e){return a.findProgramAddressSync([A.TICK_SEED,this.pool.token0.toBuffer(),this.pool.token1.toBuffer(),A.u32ToSeed(this.pool.fee),A.u32ToSeed(e)],this.program.programId)[0]}async getBitmapAddress(e){return this.getBitmapAddressSync(e)}getBitmapAddressSync(e){return a.findProgramAddressSync([A.BITMAP_SEED,this.pool.token0.toBuffer(),this.pool.token1.toBuffer(),A.u32ToSeed(this.pool.fee),A.u16ToSeed(e)],this.program.programId)[0]}getBitmap(e){let t=this.bitmapCache.get(e);if(!t)throw new Error("Bitmap not cached");return t}nextInitializedTickWithinOneWord(e,t,n){let o=w.default.toNumber(w.default.divide(w.default.BigInt(e),w.default.BigInt(n)));e<0&&e%n!=0&&(o-=1),t||(o+=1);const{wordPos:i,bitPos:r}=A.tickPosition(o),a=this.getBitmap(i),{next:s,initialized:u}=A.nextInitializedBit(a.word,r,t);return[A.buildTick(i,s,n),u,i,r,a.address]}updateCachedAccountInfos(e){for(const t of this.accountsToFetch.bitmaps){const n=e.get(t.toBase58());if(n){const e=this.program.coder.accounts.decode("tickBitmapState",n.data);this.bitmapCache.set(e.wordPos,{address:t,word:A.generateBitmapWord(e.word)})}}for(const t of this.accountsToFetch.ticks){const n=e.get(t.toBase58());if(n){const e=this.program.coder.accounts.decode("tickState",n.data);this.tickCache.set(e.tick,{address:t,liquidityNet:w.default.BigInt(e.liquidityNet)})}}}}const Dt=w.default.BigInt(1e6),Et=new P.Program(A.IDL,G,new P.AnchorProvider(null,null,{skipPreflight:!1}));class Lt{constructor(t,n){let o;this.address=void 0,this.label="Cykura",this.id=void 0,this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.poolState=void 0,this.pool=void 0,this.tickDataProvider=void 0,this.tokens=void 0,this.vaults=void 0,this.feePct=void 0,this.fee=void 0,this.address=t,this.id=t.toBase58(),o="data"in n?Et.coder.accounts.decode("poolState",n.data):n,this.poolState=o;const{token0:i,token1:r,fee:s,sqrtPriceX32:u,liquidity:c,tick:m}=this.poolState;this.tickDataProvider=new Ot(Et,{token0:i,token1:r,fee:s}),this.tokens={token0:new S.Token(101,i,0,"",""),token1:new S.Token(101,r,0,"","")},this.pool=new A.Pool(this.tokens.token0,this.tokens.token1,s,w.default.BigInt(u.toString()),w.default.BigInt(c.toString()),m,this.tickDataProvider),this.vaults={vault0:a.findProgramAddressSync([this.address.toBuffer(),e.TOKEN_PROGRAM_ID.toBuffer(),i.toBuffer()],e.ASSOCIATED_TOKEN_PROGRAM_ID)[0],vault1:a.findProgramAddressSync([this.address.toBuffer(),e.TOKEN_PROGRAM_ID.toBuffer(),r.toBuffer()],e.ASSOCIATED_TOKEN_PROGRAM_ID)[0]},this.fee=w.default.BigInt(this.poolState.fee),this.feePct=this.poolState.fee/w.default.toNumber(Dt)}getAccountsForUpdate(){return[this.address,...this.tickDataProvider.lazyLoadAccountsToCache(this.pool.tickCurrent,this.pool.tickSpacing)]}update(e){const t=e.get(this.address.toBase58());if(!t)throw new Error(`Could not find poolAccountInfo ${this.address.toBase58()}`);this.poolState=Et.coder.accounts.decode("poolState",t.data);const{fee:n,sqrtPriceX32:o,liquidity:i,tick:r}=this.poolState;this.pool=new A.Pool(this.tokens.token0,this.tokens.token1,n,w.default.BigInt(o.toString()),w.default.BigInt(i.toString()),r,this.tickDataProvider),this.tickDataProvider.updateCachedAccountInfos(e)}getQuote({sourceMint:e,amount:t}){const n=e.equals(this.poolState.token0)?this.tokens.token0:this.tokens.token1,[o,i,r]=this.pool.getOutputAmount(S.CurrencyAmount.fromRawAmount(n,t)),a=m.toDecimal(w.default.subtract(this.pool.sqrtRatioX32,i.sqrtRatioX32)).div(this.pool.sqrtRatioX32.toString());return{notEnoughLiquidity:!1,inAmount:t,outAmount:o.quotient,feeAmount:w.default.divide(w.default.multiply(t,this.fee),Dt),feeMint:e.toBase58(),feePct:this.feePct,priceImpactPct:a.toNumber()}}createSwapInstructions(e){const[t,n]=e.sourceMint.equals(this.poolState.token0)?[this.vaults.vault0,this.vaults.vault1]:[this.vaults.vault1,this.vaults.vault0],o=a.findProgramAddressSync([A.OBSERVATION_SEED,this.poolState.token0.toBuffer(),this.poolState.token1.toBuffer(),A.u32ToSeed(this.poolState.fee),A.u16ToSeed(this.poolState.observationIndex)],G)[0],i=e.sourceMint.equals(this.poolState.token0)?this.tokens.token0:this.tokens.token1,[,,r]=this.pool.getOutputAmount(S.CurrencyAmount.fromRawAmount(i,e.inAmount)),s=a.findProgramAddressSync([A.OBSERVATION_SEED,this.poolState.token0.toBuffer(),this.poolState.token1.toBuffer(),A.u32ToSeed(this.poolState.fee),A.u16ToSeed((this.poolState.observationIndex+1)%this.poolState.observationCardinalityNext)],G)[0],u={poolAddress:this.address,inputVault:t,outputVault:n,nextObservationState:s,lastObservationState:o,swapAccountMetas:r};return[qe({...e,inAmount:e.amount,minimumOutAmount:e.otherAmountThreshold,additionalArgs:u})]}get reserveTokenMints(){return[this.poolState.token0,this.poolState.token1]}}var Rt="marinade_finance",qt=[{name:"initialize",accounts:[{name:"creatorAuthority",isMut:!1,isSigner:!0},{name:"state",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!1,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!1,isSigner:!1},{name:"operationalSolAccount",isMut:!1,isSigner:!1},{name:"liqPool",accounts:[{name:"lpMint",isMut:!1,isSigner:!1},{name:"solLegPda",isMut:!1,isSigner:!1},{name:"msolLeg",isMut:!1,isSigner:!1}]},{name:"treasuryMsolAccount",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"data",type:{defined:"InitializeData"}}]},{name:"changeAuthority",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"adminAuthority",isMut:!1,isSigner:!0}],args:[{name:"data",type:{defined:"ChangeAuthorityData"}}]},{name:"addValidator",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"validatorVote",isMut:!1,isSigner:!1},{name:"duplicationFlag",isMut:!0,isSigner:!1},{name:"rentPayer",isMut:!0,isSigner:!0},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"score",type:"u32"}]},{name:"removeValidator",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"duplicationFlag",isMut:!0,isSigner:!1},{name:"operationalSolAccount",isMut:!0,isSigner:!1}],args:[{name:"index",type:"u32"},{name:"validatorVote",type:"publicKey"}]},{name:"setValidatorScore",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1}],args:[{name:"index",type:"u32"},{name:"validatorVote",type:"publicKey"},{name:"score",type:"u32"}]},{name:"configValidatorSystem",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"managerAuthority",isMut:!1,isSigner:!0}],args:[{name:"extraRuns",type:"u32"}]},{name:"deposit",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"liqPoolMsolLegAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"transferFrom",isMut:!0,isSigner:!0},{name:"mintTo",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"lamports",type:"u64"}]},{name:"depositStakeAccount",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeAuthority",isMut:!1,isSigner:!0},{name:"duplicationFlag",isMut:!0,isSigner:!1},{name:"rentPayer",isMut:!0,isSigner:!0},{name:"msolMint",isMut:!0,isSigner:!1},{name:"mintTo",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"validatorIndex",type:"u32"}]},{name:"liquidUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"getMsolFrom",isMut:!0,isSigner:!1},{name:"getMsolFromAuthority",isMut:!1,isSigner:!0},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"msolAmount",type:"u64"}]},{name:"addLiquidity",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"lpMint",isMut:!0,isSigner:!1},{name:"lpMintAuthority",isMut:!1,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!1,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"transferFrom",isMut:!0,isSigner:!0},{name:"mintTo",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"lamports",type:"u64"}]},{name:"removeLiquidity",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"lpMint",isMut:!0,isSigner:!1},{name:"burnFrom",isMut:!0,isSigner:!1},{name:"burnFromAuthority",isMut:!1,isSigner:!0},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"transferMsolTo",isMut:!0,isSigner:!1},{name:"liqPoolSolLegPda",isMut:!0,isSigner:!1},{name:"liqPoolMsolLeg",isMut:!0,isSigner:!1},{name:"liqPoolMsolLegAuthority",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"tokens",type:"u64"}]},{name:"setLpParams",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"adminAuthority",isMut:!1,isSigner:!0}],args:[{name:"minFee",type:{defined:"Fee"}},{name:"maxFee",type:{defined:"Fee"}},{name:"liquidityTarget",type:"u64"}]},{name:"configMarinade",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"adminAuthority",isMut:!1,isSigner:!0}],args:[{name:"params",type:{defined:"ConfigMarinadeParams"}}]},{name:"orderUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"burnMsolFrom",isMut:!0,isSigner:!1},{name:"burnMsolAuthority",isMut:!1,isSigner:!0},{name:"newTicketAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}],args:[{name:"msolAmount",type:"u64"}]},{name:"claim",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"ticketAccount",isMut:!0,isSigner:!1},{name:"transferSolTo",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[]},{name:"stakeReserve",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"validatorVote",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"epochSchedule",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeConfig",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"validatorIndex",type:"u32"}]},{name:"updateActive",accounts:[{name:"common",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeWithdrawAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}]},{name:"validatorList",isMut:!0,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]},{name:"updateDeactivated",accounts:[{name:"common",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeWithdrawAuthority",isMut:!1,isSigner:!1},{name:"reservePda",isMut:!0,isSigner:!1},{name:"msolMint",isMut:!0,isSigner:!1},{name:"msolMintAuthority",isMut:!1,isSigner:!1},{name:"treasuryMsolAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1},{name:"tokenProgram",isMut:!1,isSigner:!1}]},{name:"operationalSolAccount",isMut:!0,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"}]},{name:"deactivateStake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"reservePda",isMut:!1,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"splitStakeAccount",isMut:!0,isSigner:!0},{name:"splitStakeRentPayer",isMut:!0,isSigner:!0},{name:"clock",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1},{name:"epochSchedule",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"systemProgram",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]},{name:"emergencyUnstake",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"validatorManagerAuthority",isMut:!1,isSigner:!0},{name:"validatorList",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"stakeAccount",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"stakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]},{name:"mergeStakes",accounts:[{name:"state",isMut:!0,isSigner:!1},{name:"stakeList",isMut:!0,isSigner:!1},{name:"validatorList",isMut:!0,isSigner:!1},{name:"destinationStake",isMut:!0,isSigner:!1},{name:"sourceStake",isMut:!0,isSigner:!1},{name:"stakeDepositAuthority",isMut:!1,isSigner:!1},{name:"stakeWithdrawAuthority",isMut:!1,isSigner:!1},{name:"operationalSolAccount",isMut:!0,isSigner:!1},{name:"clock",isMut:!1,isSigner:!1},{name:"stakeHistory",isMut:!1,isSigner:!1},{name:"stakeProgram",isMut:!1,isSigner:!1}],args:[{name:"destinationStakeIndex",type:"u32"},{name:"sourceStakeIndex",type:"u32"},{name:"validatorIndex",type:"u32"}]}],xt=[{name:"State",type:{kind:"struct",fields:[{name:"msolMint",type:"publicKey"},{name:"adminAuthority",type:"publicKey"},{name:"operationalSolAccount",type:"publicKey"},{name:"treasuryMsolAccount",type:"publicKey"},{name:"reserveBumpSeed",type:"u8"},{name:"msolMintAuthorityBumpSeed",type:"u8"},{name:"rentExemptForTokenAcc",type:"u64"},{name:"rewardFee",type:{defined:"Fee"}},{name:"stakeSystem",type:{defined:"StakeSystem"}},{name:"validatorSystem",type:{defined:"ValidatorSystem"}},{name:"liqPool",type:{defined:"LiqPool"}},{name:"availableReserveBalance",type:"u64"},{name:"msolSupply",type:"u64"},{name:"msolPrice",type:"u64"},{name:"circulatingTicketCount",type:"u64"},{name:"circulatingTicketBalance",type:"u64"},{name:"lentFromReserve",type:"u64"},{name:"minDeposit",type:"u64"},{name:"minWithdraw",type:"u64"},{name:"stakingSolCap",type:"u64"},{name:"emergencyCoolingDown",type:"u64"}]}},{name:"TicketAccountData",type:{kind:"struct",fields:[{name:"stateAddress",type:"publicKey"},{name:"beneficiary",type:"publicKey"},{name:"lamportsAmount",type:"u64"},{name:"createdEpoch",type:"u64"}]}}],Nt=[{name:"Fee",type:{kind:"struct",fields:[{name:"basisPoints",type:"u32"}]}},{name:"InitializeData",type:{kind:"struct",fields:[{name:"adminAuthority",type:"publicKey"},{name:"validatorManagerAuthority",type:"publicKey"},{name:"minStake",type:"u64"},{name:"rewardFee",type:{defined:"Fee"}},{name:"liqPool",type:{defined:"LiqPoolInitializeData"}},{name:"additionalStakeRecordSpace",type:"u32"},{name:"additionalValidatorRecordSpace",type:"u32"},{name:"slotsForStakeDelta",type:"u64"}]}},{name:"LiqPoolInitializeData",type:{kind:"struct",fields:[{name:"lpLiquidityTarget",type:"u64"},{name:"lpMaxFee",type:{defined:"Fee"}},{name:"lpMinFee",type:{defined:"Fee"}},{name:"lpTreasuryCut",type:{defined:"Fee"}}]}},{name:"ChangeAuthorityData",type:{kind:"struct",fields:[{name:"admin",type:{option:"publicKey"}},{name:"validatorManager",type:{option:"publicKey"}},{name:"operationalSolAccount",type:{option:"publicKey"}},{name:"treasuryMsolAccount",type:{option:"publicKey"}}]}},{name:"ConfigMarinadeParams",type:{kind:"struct",fields:[{name:"rewardsFee",type:{option:{defined:"Fee"}}},{name:"slotsForStakeDelta",type:{option:"u64"}},{name:"minStake",type:{option:"u64"}},{name:"minDeposit",type:{option:"u64"}},{name:"minWithdraw",type:{option:"u64"}},{name:"stakingSolCap",type:{option:"u64"}},{name:"liquiditySolCap",type:{option:"u64"}},{name:"autoAddValidatorEnabled",type:{option:"bool"}}]}},{name:"LiqPool",type:{kind:"struct",fields:[{name:"lpMint",type:"publicKey"},{name:"lpMintAuthorityBumpSeed",type:"u8"},{name:"solLegBumpSeed",type:"u8"},{name:"msolLegAuthorityBumpSeed",type:"u8"},{name:"msolLeg",type:"publicKey"},{name:"lpLiquidityTarget",type:"u64"},{name:"lpMaxFee",type:{defined:"Fee"}},{name:"lpMinFee",type:{defined:"Fee"}},{name:"treasuryCut",type:{defined:"Fee"}},{name:"lpSupply",type:"u64"},{name:"lentFromSolLeg",type:"u64"},{name:"liquiditySolCap",type:"u64"}]}},{name:"List",type:{kind:"struct",fields:[{name:"account",type:"publicKey"},{name:"itemSize",type:"u32"},{name:"count",type:"u32"},{name:"newAccount",type:"publicKey"},{name:"copiedCount",type:"u32"}]}},{name:"StakeRecord",type:{kind:"struct",fields:[{name:"stakeAccount",type:"publicKey"},{name:"lastUpdateDelegatedLamports",type:"u64"},{name:"lastUpdateEpoch",type:"u64"},{name:"isEmergencyUnstaking",type:"u8"}]}},{name:"StakeSystem",type:{kind:"struct",fields:[{name:"stakeList",type:{defined:"List"}},{name:"delayedUnstakeCoolingDown",type:"u64"},{name:"stakeDepositBumpSeed",type:"u8"},{name:"stakeWithdrawBumpSeed",type:"u8"},{name:"slotsForStakeDelta",type:"u64"},{name:"lastStakeDeltaEpoch",type:"u64"},{name:"minStake",type:"u64"},{name:"extraStakeDeltaRuns",type:"u32"}]}},{name:"ValidatorRecord",type:{kind:"struct",fields:[{name:"validatorAccount",type:"publicKey"},{name:"activeBalance",type:"u64"},{name:"score",type:"u32"},{name:"lastStakeDeltaEpoch",type:"u64"},{name:"duplicationFlagBumpSeed",type:"u8"}]}},{name:"ValidatorSystem",type:{kind:"struct",fields:[{name:"validatorList",type:{defined:"List"}},{name:"managerAuthority",type:"publicKey"},{name:"totalValidatorScore",type:"u32"},{name:"totalActiveBalance",type:"u64"},{name:"autoAddValidatorEnabled",type:"u8"}]}},{name:"CommonError",type:{kind:"enum",variants:[{name:"InvalidProgramId",fields:["publicKey"]},{name:"UnexpectedAccount",fields:["publicKey"]},{name:"CalculationFailure"},{name:"AccountWithLockup"},{name:"NumberTooLow",fields:["u64","u64"]},{name:"NumberTooHigh",fields:["u64","u64"]},{name:"FeeTooHigh",fields:[{defined:"Fee"}]},{name:"FeesWrongWayRound",fields:[{defined:"Fee"},{defined:"Fee"}]},{name:"LiquidityTargetTooLow"},{name:"TicketNotDue",fields:["u64"]},{name:"TicketNotReady"},{name:"WrongBeneficiary"},{name:"InsufficientLiquidity"},{name:"InvalidValidator"}]}},{name:"InitializeError",type:{kind:"enum",variants:[{name:"WrongReserveOwner",fields:["publicKey"]},{name:"NonEmptyReserveData",fields:[{defined:"usize"}]},{name:"InvalidInitialReserveLamports",fields:["u64"]},{name:"ZeroValidatorChunkSize"},{name:"TooBigValidatorChunkSize",fields:["u32"]},{name:"ZeroCreditChunkSize"},{name:"TooBigCreditChunkSize",fields:["u32"]},{name:"TooLowCreditFee",fields:["u64"]},{name:"InvalidMintAuthority",fields:[{name:"expected",type:"publicKey"},{name:"got",type:"publicKey"}]},{name:"MintHasInitialSupply",fields:["u64"]},{name:"InvalidOwnerFeeState",fields:[{defined:"spl_token::state::AccountState"}]}]}}],Kt={__proto__:null,version:"0.0.0",name:Rt,instructions:qt,accounts:xt,types:Nt,default:{version:"0.0.0",name:Rt,instructions:qt,accounts:xt,types:Nt}};function Ct(e,t,n){return n.isZero()?e:e.mul(t).div(n)}class Ut{constructor(e,t){this.address=void 0,this.id=void 0,this.label="Marinade",this.shouldPrefetch=!0,this.exactOutputSupported=!1,this.marinadeFinanceProgram=void 0,this.marinadeStateResponse=void 0,this.liqPoolSolLegPdaAddress=void 0,this.marinadeState=void 0,this.id=e.toBase58(),this.marinadeFinanceProgram=new r.Program(Kt,j,{}),this.marinadeStateResponse=this.marinadeFinanceProgram.coder.accounts.decode("State",t.data),this.address=e,this.liqPoolSolLegPdaAddress=this.findProgramDerivedAddress("liq_sol")}getAccountsForUpdate(){return[this.address,this.liqPoolSolLegPdaAddress,this.marinadeStateResponse.liqPool.msolLeg]}update(e){const[t,n,o]=je(e,this.getAccountsForUpdate());this.marinadeStateResponse=this.marinadeFinanceProgram.coder.accounts.decode("State",t.data);const i=p.deserializeAccount(o.data);if(!i)throw new Error(`liqPoolMSOLLeg token account cannot be deserialized ${this.marinadeStateResponse.liqPool.msolLeg.toBase58()}`);this.marinadeState=new _t(this.marinadeStateResponse,new T.default(n.lamports),i.amount)}getQuote({sourceMint:t,amount:n}){if(!this.marinadeState)throw new Error("Update was not run to create a complete marinadeState");const o=new T.default(n.toString()),i=t.equals(e.NATIVE_MINT)?this.marinadeState.depositQuote(o):this.marinadeState.liquidUnstakeQuote(o);return{notEnoughLiquidity:!1,inAmount:n,outAmount:w.default.BigInt(i.outAmount.toString()),feeAmount:w.default.BigInt(i.feeAmount.toString()),feeMint:this.marinadeStateResponse.msolMint.toBase58(),feePct:i.feePct,priceImpactPct:0}}createSwapInstructions(t){return[t.sourceMint.equals(e.NATIVE_MINT)?xe({...t,additionalArgs:{address:this.address,marinadeStateResponse:this.marinadeStateResponse,liqPoolSolLegPda:this.liqPoolSolLegPdaAddress,liqPoolMsolLegAuthority:this.findProgramDerivedAddress("liq_st_sol_authority"),reservePda:this.findProgramDerivedAddress("reserve"),msolMintAuthority:this.findProgramDerivedAddress("st_mint")},inAmount:t.amount,minimumOutAmount:t.otherAmountThreshold}):Ne({...t,additionalArgs:{address:this.address,marinadeStateResponse:this.marinadeStateResponse,liqPoolSolLegPda:this.liqPoolSolLegPdaAddress},inAmount:t.amount,minimumOutAmount:t.otherAmountThreshold})]}get reserveTokenMints(){return[e.NATIVE_MINT,this.marinadeStateResponse.msolMint]}findProgramDerivedAddress(e,t=[]){const n=[this.address.toBuffer(),Buffer.from(e),...t],[o]=a.findProgramAddressSync(n,this.marinadeFinanceProgram.programId);return o}}class _t{constructor(e,t,n){this.state=void 0,this.liqPoolSolLegPdaLamports=void 0,this.liqPoolMSOLLegAmount=void 0,this.state=e,this.liqPoolSolLegPdaLamports=t,this.liqPoolMSOLLegAmount=n}depositQuote(e){let t=e;const n=this.calcMSOLFromLamports(t),o=T.default.min(n,this.liqPoolMSOLLegAmount);let i=new T.default(0);if(t=(()=>{if(o.gt(new T.default(0))){const e=n.eq(o)?t:this.calcLamportsFromMSOLAmount(o);return i=i.add(o),Vt(t,e)}return t})(),t.gt(new T.default(0))){this.checkStakingCap(t);const e=this.calcMSOLFromLamports(t);i=i.add(e)}return{outAmount:i,feeAmount:0,feePct:0,priceImpactPct:0}}checkStakingCap(e){if(this.totalLamportsUnderControl().add(e).gt(this.state.stakingSolCap))throw new Error("Staking cap reached")}calcMSOLFromLamports(e){return t=e,n=this.totalVirtualStakedLamports(),(o=this.state.msolSupply).eq(new T.default(0))?t:Ct(t,o,n);var t,n,o}calcLamportsFromMSOLAmount(e){return Ct(e,this.totalVirtualStakedLamports(),this.state.msolSupply)}totalVirtualStakedLamports(){return Vt(this.totalLamportsUnderControl(),this.state.circulatingTicketBalance)}totalLamportsUnderControl(){return this.state.validatorSystem.totalActiveBalance.add(this.totalCoolingDown()).add(this.state.availableReserveBalance)}totalCoolingDown(){return this.state.stakeSystem.delayedUnstakeCoolingDown.add(this.state.emergencyCoolingDown)}liquidUnstakeQuote(e){const t=Vt(this.liqPoolSolLegPdaLamports,this.state.rentExemptForTokenAcc),n=this.calcLamportsFromMSOLAmount(e),o=function(e,t,n,o,i){if(i.gte(o))return t;const r=o.sub(i);return r.gte(n)?e:t-Ct(new T.default(t-e),r,n).toNumber()}(this.state.liqPool.lpMinFee.basisPoints,this.state.liqPool.lpMaxFee.basisPoints,this.state.liqPool.lpLiquidityTarget,t,n),i=e.mul(new T.default(o)).div(new T.default(1e4)),r=this.calcLamportsFromMSOLAmount(e.sub(i));if(r.add(this.state.rentExemptForTokenAcc).gt(this.liqPoolSolLegPdaLamports))throw new Error("Insufficient liquidity");return{outAmount:r,feeAmount:i,feePct:o/1e4,priceImpactPct:0}}}function Vt(e,t){return e.gt(t)?e.sub(t):new T.default(0)}const Wt={};function Gt(e){const t=e._bn.toString(),n=Wt[t];if(n)return n;{const n=e.toBase58();return Wt[t]=n,n}}function zt(e,t,n){return Boolean(e&&t>100&&!e.includes(n))}function jt(e,t){if(e===exports.SwapMode.ExactOut)return!1;if(t.length>1){const[e,n]=t;if(e instanceof He&&n instanceof He)return!1}return!0}async function Qt({connection:n,amount:o,owner:{publicKey:i}}){const r={instructions:[],cleanupInstructions:[],signers:[]};r.instructions=[];const a=await e.Token.getAssociatedTokenAddress(e.ASSOCIATED_TOKEN_PROGRAM_ID,e.TOKEN_PROGRAM_ID,F,i,!0);return null===await n.getAccountInfo(a)&&r.instructions.push(Ht(i,a,i,F)),r.instructions.push(t.SystemProgram.transfer({fromPubkey:i,toPubkey:a,lamports:w.default.toNumber(o)})),r.instructions.push(e.Token.createSyncNativeInstruction(e.TOKEN_PROGRAM_ID,a)),r.cleanupInstructions=[e.Token.createCloseAccountInstruction(e.TOKEN_PROGRAM_ID,a,i,i,[])],{address:a,...r}}async function Zt({connection:n,payer:o,owner:{publicKey:i},mintAddress:r,unwrapSOL:a}){const s="string"==typeof r?new t.PublicKey(r):r,u=await e.Token.getAssociatedTokenAddress(e.ASSOCIATED_TOKEN_PROGRAM_ID,e.TOKEN_PROGRAM_ID,s,i,!0),c=[],m=[],d=await n.getAccountInfo(u);if(null===d)m.push(Ht(o,u,i,s));else{const e=p.deserializeAccount(d.data);if(e&&!e.owner.equals(i))throw new Error(`/! ATA ${u.toBase58()} is not owned by ${i.toBase58()}`)}return s.equals(F)&&a&&c.push(e.Token.createCloseAccountInstruction(e.TOKEN_PROGRAM_ID,u,i,i,[])),{address:u,instructions:m,cleanupInstructions:c,signers:[]}}function Ht(n,o,i,r,a=e.TOKEN_PROGRAM_ID,s=e.ASSOCIATED_TOKEN_PROGRAM_ID){return new t.TransactionInstruction({keys:[{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:t.SystemProgram.programId,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1}],programId:s,data:Buffer.alloc(0)})}const Yt=async({connection:e,marketInfos:t,owner:n,unwrapSOL:o})=>{const[i,r]=await Promise.all([(async()=>2===t.length?await Zt({connection:e,owner:n,payer:n.publicKey,mintAddress:t[0].outputMint,unwrapSOL:o}):void 0)(),Zt({connection:e,owner:n,payer:n.publicKey,mintAddress:2===t.length?t[1].outputMint:t[0].outputMint,unwrapSOL:o})]);return{userIntermediaryTokenAccountResult:i,userDestinationTokenAccountResult:r}};async function Xt(e,n,o,i){const r={instructions:[],cleanupInstructions:[],signers:[]},s=o.address.toString();if(i){let t=i.get(s);if(t){let n=null;if(n=await e.getAccountInfo(t,"confirmed"),n)return{...r,address:t}}}const[u,c]=function(e,n){const[o]=a.findProgramAddressSync([Buffer.from("open_orders"),e.publicKey.toBuffer(),n.toBuffer()],de);return[o,le.instruction.createOpenOrders({accounts:{openOrders:o,payer:n,dexProgram:e.programId,systemProgram:t.SystemProgram.programId,rent:t.SYSVAR_RENT_PUBKEY,market:e.publicKey}})]}(o,n);return await e.getAccountInfo(u)||(r.instructions=[c]),null==i||i.set(o.address.toString(),u),{...r,address:u}}function Jt(e){return e.reduce(((e,t)=>t+e),0)}const $t={feeBps:0,feeAccounts:new Map};async function en(t,n){return(await t.getTokenAccountsByOwner(n,{programId:e.TOKEN_PROGRAM_ID})).value.reduce(((e,t)=>{const n=p.deserializeAccount(t.account.data);return n&&e.set(n.mint.toBase58(),t.pubkey),e}),new Map)}class tn{constructor(e,t,n){this.connection=void 0,this.feePayer=void 0,this.instructions=void 0,this.owner=void 0,this.connection=e,this.feePayer=t,this.instructions=[],this.owner=n}addInstruction(e){return this.instructions.push(e),this}async build(e){e||(e=await this.connection.getLatestBlockhash("confirmed"));const n={...e,feePayer:this.feePayer};let o=[],i=[],r=[];this.instructions.forEach((e=>{o=o.concat(e.instructions),i=i.concat(e.cleanupInstructions),r=r.concat(e.signers)}));const a=new t.Transaction(n);return o.concat(i).forEach((e=>a.add(e))),a.feePayer=this.feePayer,{transaction:a,signers:r,execute:this.owner.isKeyPair?()=>this.connection.sendTransaction(a,r):async()=>{throw new Error("Please use a Keypair for the owner parameter to enable the execute function")}}}}class nn{constructor(e){this._owner=void 0,this._owner=e}get publicKey(){return nn.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return nn.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return nn.isKeyPair(this._owner)}get isPublicKey(){return nn.isPublicKey(this._owner)}static isKeyPair(e){return void 0!==e.secretKey}static isPublicKey(e){return!nn.isKeyPair(e)}}const on=e=>new Promise((t=>setTimeout(t,e)));function rn(e,t,n){if(e)return function(e,t){var n,o,i,r;const a=null===(n=t.postTokenBalances)||void 0===n||null===(o=n.find((t=>t.accountIndex===e)))||void 0===o?void 0:o.uiTokenAmount.amount,s=null===(i=t.preTokenBalances)||void 0===i||null===(r=i.find((t=>t.accountIndex===e)))||void 0===r?void 0:r.uiTokenAmount.amount;if(a)return Math.abs(parseInt(a)-(void 0!==s?parseInt(s):0))}(t.message.accountKeys.findIndex((e=>e.equals(n))),e)}function an(e,t,n){let o=t.message.accountKeys.findIndex((e=>e.equals(n)));return-1!==o?Math.abs(e.postBalances[o]-e.preBalances[o]):0}function sn(){return(new Date).getTime()}const un={skipPreflight:!0,maxRetries:2};async function cn(e,t,n=12e4,o=500,i=2e3,r=40){const a=t.serialize(),s=await e.sendRawTransaction(a,un),u=sn();let c=sn(),m=0;for(;sn()-u<n;){const t=sn();m<r&&t-c>i&&(c=t,m+=1,await e.sendRawTransaction(a,un));const n=await Promise.any([e.getTransaction(s,{commitment:"confirmed"}),on(5e3)]);if(n)return{txid:s,transactionResponse:n};await on(o)}return{txid:s,transactionResponse:null}}function mn(e){const t=e.signature;if(!t)throw new Error("Transaction has no signature");return k.bs58.encode(t)}const dn=function(e){if(!Array.isArray(e))throw new TypeError(`Argument must be an array: ${e}`)},ln=function(e,t){return e*t.length},pn={},gn=function(e,t){return String(t)},hn=w.default.BigInt(1e4);function fn({inputMint:e,outputMint:t}){return`${e}-${t}`}function An({ammId:e,amount:t}){return`${e}-${t.toString()}`}function Sn({inputRouteSegment:e,inputMint:n,outputMint:o,amount:i,getDepositAndFeeForRoute:r,platformFeeBps:a,slippage:s,filterTopNResult:u=3,onlyDirectRoutes:c,swapMode:d}){const l=n.toBase58(),p=o.toBase58(),g=new Map,h=e.get(l),f=[];if(!h)throw new Error("No routes found for the input and output mints");const A=c?0:2,S=({inputMint:n,level:o=0,walked:r=[n]})=>{const a=e.get(n);a&&a.forEach(((s,l)=>{const h=fn({inputMint:n,outputMint:l}),k=function({amms:e,inputMint:n,outputMint:o,amount:i,swapMode:r}){return e.map((e=>{try{return{quote:e.getQuote({amount:i,sourceMint:new t.PublicKey(n),destinationMint:new t.PublicKey(o),swapMode:r}),amm:e}}catch(e){return}})).filter(Boolean).sort(((e,t)=>w.default.greaterThanOrEqual((null==t?void 0:t.quote.outAmount)||m.ZERO,(null==e?void 0:e.quote.outAmount)||m.ZERO)?1:-1))}({amms:s,inputMint:n,outputMint:l,amount:i,swapMode:d}),{filteredAmms:y,quoteMap:M}=k.reduce(((e,t,n)=>(n<u&&e.filteredAmms.push(t.amm),e.quoteMap.set(An({ammId:t.amm.id,amount:i}),t.quote),e)),{filteredAmms:[],quoteMap:new Map}),P=[];if(l!==p||c||function(e,t){for(let n=0;n<e.length;n++)for(let o=n+1;o<e.length;o++)e[n].label!==e[o].label&&t(e[n],e[o])}(y.slice(),((e,t)=>{const n=tt.create(e,t);n&&P.push(n)})),a.set(l,y.concat(P)),g.set(h,M),l!==p&&M.size&&!r.includes(l)&&o<A-1)S({inputMint:l,amount:M.values().next().value.outAmount,level:o+1,walked:r.concat(l)});else if(l===p){0===o&&a.set(l,k.map((e=>e.amm)).concat(P));const n=r.concat(l),i=n.map((e=>new t.PublicKey(e))),s=n.reduce(((t,o,i)=>{var r;return i<n.length-1&&t.push(null===(r=e.get(n[i]))||void 0===r?void 0:r.get(n[i+1])),t}),[]);(function(e){if(function(e){if(!Array.isArray(e))throw new TypeError("Argument must be an array of arrays");e.forEach(dn),function({length:e}){if(e>=100)throw new TypeError(`Too many arrays (${e}): please use the 'big-cartesian' library instead of 'fast-cartesian'`)}(e),function(e){const t=e.reduce(ln,1);if(t>=4294967296){const e=Number.isFinite(t)?` (${t.toExponential(0)})`:"";throw new TypeError(`Too many combinations${e}: please use the 'big-cartesian' library instead of 'fast-cartesian'`)}}(e)}(e),0===e.length)return[];const t=[];return function(e){const t=pn[e];if(void 0!==t)return t;const n=function(e){const t=Array.from({length:e},gn),n=t.map((e=>`for (const value${e} of arrays[${e}]) {`)).join("\n"),o=t.map((e=>`value${e}`)).join(", "),i="}\n".repeat(e);return new Function("arrays","result",`${n}\nresult.push([${o}])\n${i}`)}(e);return pn[e]=n,n}(e.length)(e,t),t})(s).forEach((e=>{(1===e.length||nt(e[0],e[1]))&&f.push({amms:e,mints:i})}))}}))};return S({inputMint:l,amount:i}),f.map((e=>{const{amms:t,mints:n}=e;let o=[],u=i,c=m.ZERO;const l=jt(d,t),p=n,h=t.length;for(const[e,n]of t.entries())try{var f;const t=p[e],r=p[e+1],A=fn({inputMint:t.toBase58(),outputMint:r.toBase58()}),S=(null===(f=g.get(A))||void 0===f?void 0:f.get(An({ammId:n.id,amount:u})))||n.getQuote({sourceMint:t,destinationMint:r,amount:u,swapMode:d}),k=h-1===e&&l?{amount:w.default.divide(w.default.multiply(S.outAmount,w.default.BigInt(a)),hn),mint:r.toBase58(),pct:a/100}:{amount:m.ZERO,mint:r.toBase58(),pct:0},y=d===exports.SwapMode.ExactIn?S.outAmount:S.inAmount;let M=d===exports.SwapMode.ExactIn?w.default.subtract(y,k.amount):w.default.add(y,k.amount);w.default.lessThan(M,m.ZERO)&&(M=m.ZERO);const P=w.default.BigInt(d===exports.SwapMode.ExactIn?new v.default(M.toString()).mul(1-s/100).ceil():new v.default(M.toString()).mul(1+s/100).floor()),[T,b]=d===exports.SwapMode.ExactIn?[S.inAmount,M]:[M,u];o.push({amm:n,inputMint:t,outputMint:r,notEnoughLiquidity:S.notEnoughLiquidity,minInAmount:S.minInAmount,minOutAmount:S.minOutAmount,inAmount:T,outAmount:b,priceImpactPct:S.priceImpactPct,lpFee:{amount:S.feeAmount,mint:S.feeMint,pct:S.feePct},platformFee:k}),u=d===exports.SwapMode.ExactIn?M:i,c=P}catch(e){return}return{marketInfos:o,getDepositAndFee:()=>r({marketInfos:o}),inAmount:o[0].inAmount,outAmount:u,amount:i,otherAmountThreshold:c,swapMode:d,priceImpactPct:1-o.reduce(((e,t)=>e*(1-t.priceImpactPct)),1)}})).filter((e=>void 0!==e)).sort(((e,t)=>w.default.greaterThanOrEqual(t.outAmount,e.outAmount)?1:-1))}const kn=Object.values($).reduce(((e,t)=>(e[t.code]=t,e)),{});async function yn({txid:e,transactionResponse:t}){var n;if(!t)return new p.TransactionError("Transaction was not confirmed",e);if(null!=t&&null!==(n=t.meta)&&void 0!==n&&n.err){let{message:n,programId:i,code:r}=p.parseErrorForTransaction(t);var o;return i===de.toBase58()&&r&&(n=null===(o=kn[r])||void 0===o?void 0:o.msg),n||(n=p.UNKNOWN_ERROR),new p.TransactionError(n||"",e,r)}return t}function Mn(e,t){let n=t.get(e);return void 0===n&&(n=t.size,t.set(e,n)),n}function wn(e){const t=t=>e.mintKeys[t],n=new Map;return Object.keys(e.indexedRouteMap).forEach((o=>{n.set(t(o),e.indexedRouteMap[o].map((e=>t(e))))})),n}class Pn{constructor(t,n,o,i,r,a,u=0,c=!0,d,l,p){this.connection=void 0,this.cluster=void 0,this.tokenRouteSegments=void 0,this.feeCalculator=void 0,this.platformFeeAndAccounts=void 0,this.quoteMintToReferrer=void 0,this.routeCacheDuration=void 0,this.wrapUnwrapSOL=void 0,this.tokenLedger=void 0,this.intermediateTokens=void 0,this.shouldLoadSerumOpenOrders=void 0,this.serumOpenOrdersPromise=void 0,this.user=void 0,this.routeCache=new Map,this.getDepositAndFees=async({marketInfos:e,userPublicKey:t,serumOpenOrdersPromise:n=Promise.resolve(new Map)})=>(async({connection:e,owner:t,inputMint:n,marketInfos:o,feeCalculator:i,serumOpenOrdersPromise:r,wrapUnwrapSOL:a})=>{const s=n.equals(F)&&a,u=Promise.all(o.map((async n=>{const o=n.amm;if(o instanceof $e||o instanceof tt){if(!o.market)return;return await Xt(e,t.publicKey,o.market,await r)}}))),c=Yt({connection:e,marketInfos:o,owner:t,unwrapSOL:a}).then((({userIntermediaryTokenAccountResult:e,userDestinationTokenAccountResult:t})=>u.then((n=>({intermediate:e,destination:t,openOrders:n})))));return(({intermediate:e,destination:t,openOrders:n,hasWrapUnwrapSOL:o,feeCalculator:i})=>{const r=n.filter((e=>e&&e.instructions.length>0)).map((()=>23352760)),a=[e,t].filter((e=>(null==e?void 0:e.instructions.length)&&0===e.cleanupInstructions.length)).map((()=>2039280)),s=([...null==n?void 0:n.map((e=>null==e?void 0:e.signers)),null==e?void 0:e.signers,t.signers].filter(Boolean).flat().length+1)*i.lamportsPerSignature;return{signatureFee:s,openOrdersDeposits:r,ataDeposits:a,totalFeeAndDeposits:Jt([s,...r,...a]),minimumSOLForTransaction:Jt([s,...r,...[e,t].filter((e=>{var t;return(null!==(t=null==e?void 0:e.instructions.length)&&void 0!==t?t:0)>0})).map((()=>2039280)),o?2039280:0])}})({...await c,hasWrapUnwrapSOL:s,feeCalculator:i})})({connection:this.connection,feeCalculator:this.feeCalculator,inputMint:e[0].inputMint,marketInfos:e,serumOpenOrdersPromise:n,owner:new nn(t),wrapUnwrapSOL:this.wrapUnwrapSOL}),this.getDepositAndFeesForUser=({marketInfos:e})=>{if(this.user&&this.serumOpenOrdersPromise){const t=new nn(this.user);return this.getDepositAndFees({marketInfos:e,userPublicKey:t.publicKey,serumOpenOrdersPromise:this.serumOpenOrdersPromise})}return Promise.resolve(void 0)},this.exchange=async({routeInfo:t,userPublicKey:n,feeAccount:o,wrapUnwrapSOL:i,tokenLedger:r,blockhashWithExpiryBlockHeight:a})=>{var u;const{connection:c,serumOpenOrdersPromise:d}=this,l=n||this.user;if(!l)throw new Error("user not found");const p=new nn(l),g=t.marketInfos.length-1,h=t.marketInfos[0].inputMint,f=t.marketInfos[g].outputMint,A=null!=i?i:this.wrapUnwrapSOL,[S,k,y]=await Promise.all([h.equals(F)&&A?Qt({connection:c,owner:p,amount:t.swapMode===exports.SwapMode.ExactIn?t.amount:t.otherAmountThreshold}):e.Token.getAssociatedTokenAddress(e.ASSOCIATED_TOKEN_PROGRAM_ID,e.TOKEN_PROGRAM_ID,h,p.publicKey,!0).then((e=>({instructions:[],cleanupInstructions:[],signers:[],address:e}))),Yt({connection:c,marketInfos:t.marketInfos,owner:p,unwrapSOL:A}),Promise.all(t.marketInfos.map((async({amm:e})=>{if(e instanceof $e||e instanceof tt){if(!e.market)return;return await Xt(c,p.publicKey,e.market,await d)}})))]),M={intermediate:k.userIntermediaryTokenAccountResult,destination:k.userDestinationTokenAccountResult,openOrders:y},w=M.openOrders.filter(Boolean).length>0,P=(o=o||this.platformFeeAndAccounts.feeAccounts.get(f.toBase58()))?{feeBps:this.platformFeeAndAccounts.feeBps||Math.floor(100*t.marketInfos[g].platformFee.pct),feeAccount:o}:void 0,T=await async function({user:e,tokenLedger:t,openOrdersAddresses:n,userSourceTokenAccountAddress:o,userIntermediaryTokenAccountAddress:i,userDestinationTokenAccountAddress:r,routeInfo:a,platformFee:u,quoteMintToReferrer:c}){const d=a.otherAmountThreshold,l=a.amount,p=a.marketInfos.length;if(2===p&&!i)throw new Error("Missing intermediary token account");const g=u&&function(e){if(e.length<2)return!1;const[t,n]=e.map((e=>e.amm));return t instanceof He&&n instanceof $e||t instanceof $e&&n instanceof He}(a.marketInfos)?void 0:c,h=[o,...i?[i]:[],r],f=jt(a.swapMode,a.marketInfos.map((e=>e.amm))),A=[Fe(t,h[1])];for(const[o,i]of a.marketInfos.entries()){const r=i.amm,c=0===o?new s.BN(l.toString()):null,S=o===p-1,k=new s.BN((S?d:m.ZERO).toString()),y=S&&f?u:void 0,[M,w]=h.slice(o);A.push(...r.createSwapInstructions({sourceMint:i.inputMint,destinationMint:i.outputMint,userSourceTokenAccount:M,userDestinationTokenAccount:w,userTransferAuthority:e.publicKey,inAmount:i.inAmount,amount:c,otherAmountThreshold:k,swapMode:a.swapMode,tokenLedger:t,openOrdersAddress:n[o],platformFee:y,quoteMintToReferrer:g}))}const{signers:S,cleanupInstructions:k}={instructions:[],cleanupInstructions:[],signers:[]};return e.isKeyPair&&e.signer&&S.push(e.signer),{signers:S,cleanupInstructions:k,instructions:A}}({user:p,tokenLedger:r||this.tokenLedger,openOrdersAddresses:M.openOrders.map((e=>null==e?void 0:e.address)),userSourceTokenAccountAddress:S.address,userIntermediaryTokenAccountAddress:null===(u=M.intermediate)||void 0===u?void 0:u.address,userDestinationTokenAccountAddress:M.destination.address,routeInfo:t,platformFee:P,quoteMintToReferrer:this.quoteMintToReferrer}),{needCleanup:v,needSetup:b}=function(e,{hasSerumOpenOrderInstruction:t}){let n,o;if(1===e.length){const t=e[0].amm;if(!(t instanceof tt))return{needSetup:!1,needCleanup:!1};n=t.firstAmm,o=t.secondAmm}else[n,o]=e.map((e=>e.amm));return n instanceof He||o instanceof He||n instanceof $e&&o instanceof $e?{needSetup:!0,needCleanup:!0}:t?{needSetup:!0,needCleanup:!1}:{needSetup:!1,needCleanup:!1}}(t.marketInfos,{hasSerumOpenOrderInstruction:w}),B=new tn(c,p.publicKey,p),I=new tn(c,p.publicKey,p),O=new tn(c,p.publicKey,p),D=[M.intermediate,S,!M.destination.address.equals(S.address)&&M.destination];b?(w&&M.openOrders.forEach((e=>{e&&B.addInstruction(e)})),D.forEach((e=>{if(e&&(B.addInstruction({...e,cleanupInstructions:[]}),e.cleanupInstructions.length)){const t={instructions:[],cleanupInstructions:[],signers:[],cleanupInstructions:e.cleanupInstructions};v?O.addInstruction(t):I.addInstruction(t)}}))):(w&&M.openOrders.forEach((e=>{e&&I.addInstruction(e)})),D.forEach((e=>{e&&I.addInstruction(e)}))),I.addInstruction(T),a=a||await this.connection.getLatestBlockhash("confirmed");const{transaction:E}=await B.build(a),{transaction:L}=await I.build(a),{transaction:R}=await O.build(a),[q,x,N]=[E.instructions.length?E:void 0,L,R.instructions.length?R:void 0],K=M;return{transactions:{setupTransaction:q,swapTransaction:x,cleanupTransaction:N},execute:({wallet:e,onTransaction:t}={})=>this.executeInternal({wallet:e,onTransaction:t,inputMint:h,outputMint:f,sourceInstruction:S,setupInstructions:K,setupTransaction:q,swapTransaction:x,cleanupTransaction:N,wrapUnwrapSOL:A,owner:p})}},this.connection=t,this.cluster=n,this.tokenRouteSegments=o,this.feeCalculator=i,this.platformFeeAndAccounts=r,this.quoteMintToReferrer=a,this.routeCacheDuration=u,this.wrapUnwrapSOL=c,this.tokenLedger=d,this.intermediateTokens=l,this.shouldLoadSerumOpenOrders=p}static async load({connection:e,cluster:n,user:o,platformFeeAndAccounts:i=$t,quoteMintToReferrer:r,routeCacheDuration:a=0,wrapUnwrapSOL:s=!0,marketUrl:u,restrictIntermediateTokens:c=!1,tokenLedger:m=ge,shouldLoadSerumOpenOrders:d=!0}){const[l,{value:{feeCalculator:p}},g,h]=await Promise.all([Pn.fetchTokenRouteSegments(e,n,u),e.getRecentBlockhashAndContext("processed"),null!=r?r:en(e,new t.PublicKey(_)),c?Pn.getIntermediateTokens():void 0]),f=new Pn(e,n,l,p,i,g,a,s,m,h,d);return o&&f.setUserPublicKey(o),f}getAccountToAmmMap(){const e=new Map;return this.tokenRouteSegments.forEach((t=>{Array.from(t.values()).forEach((t=>{t.forEach((t=>{t.getAccountsForUpdate().forEach((n=>{e.set(n.toBase58(),t)}))}))}))})),e}getAmmIdToAmmMap(){const e=new Map;return this.tokenRouteSegments.forEach((t=>{Array.from(t.values()).forEach((t=>{t.forEach((t=>{e.set(t.id,t)}))}))})),e}async computeRoutes({inputMint:e,outputMint:t,amount:n,slippage:o,feeBps:i=0,forceFetch:r,onlyDirectRoutes:a,swapMode:s=exports.SwapMode.ExactIn,filterTopNResult:u}){const c=e.toBase58(),m=t.toBase58(),d=i||(this.platformFeeAndAccounts.feeAccounts.get(m)?this.platformFeeAndAccounts.feeBps:0),l=(new Date).getTime(),p=[c,m].sort(((e,t)=>e.localeCompare(t))).join(""),g=this.routeCache.get(p),h=function({inputMint:e,outputMint:t,tokenRouteSegments:n,intermediateTokens:o,swapMode:i,onlyDirectRoutes:r}){const a=new Map,s=n.get(e),u=n.get(t);if(s&&u){const n=Math.min(s.size,u.size),c=s.size<u.size,m=new Map,d=new Map;let[l,p,g,h]=c?[s,u,e,t]:[u,s,t,e];for(let[e,t]of l.entries()){let s=i===exports.SwapMode.ExactIn?t:t.filter((e=>e.exactOutputSupported));if(e===h){m.set(e,s),d.set(g,s);continue}if(r||i===exports.SwapMode.ExactOut||zt(o,n,e))continue;const u=p.get(e);if(u){let t=i===exports.SwapMode.ExactIn?u:u.filter((e=>e.exactOutputSupported));a.set(e,new Map([[g,s],[h,t]])),m.set(e,s),d.set(e,t)}}a.set(g,m),a.set(h,d)}return a}({inputMint:c,outputMint:m,tokenRouteSegments:this.tokenRouteSegments,intermediateTokens:this.intermediateTokens,onlyDirectRoutes:a,swapMode:s});let f=!1;if(-1===this.routeCacheDuration)f=!1;else if(0===this.routeCacheDuration)f=!0;else if(g){const{fetchTimestamp:e}=g;l-e>this.routeCacheDuration&&(f=!0)}else f=!0;(r||f)&&(await async function(e,t){const n=new Map,o=new Set,i=new Map;t.forEach((e=>{e.forEach((e=>{e.forEach((e=>{i.set(e.id,e),e.getAccountsForUpdate().forEach((e=>{o.add(e.toBase58())}))}))}))}));const r=Array.from(o);r.length>0&&((await Ge(e,r)).forEach(((e,t)=>{e&&n.set(r[t],e)})),i.forEach((e=>{e.update(n)})))}(this.connection,h),this.routeCache.set(p,{fetchTimestamp:(new Date).getTime()}));try{return{routesInfos:Sn({inputRouteSegment:h,inputMint:e,outputMint:t,amount:n,getDepositAndFeeForRoute:this.getDepositAndFeesForUser,onlyDirectRoutes:a,slippage:o,platformFeeBps:d,filterTopNResult:u,swapMode:s}),cached:!(r||f)}}catch(e){throw e}finally{this.routeCache.forEach((({fetchTimestamp:e},t)=>{e-l>this.routeCacheDuration&&this.routeCache.delete(t)}))}}setUserPublicKey(e){this.user=e;const t=new nn(this.user);this.serumOpenOrdersPromise=this.shouldLoadSerumOpenOrders?Pn.findSerumOpenOrdersForOwner({connection:this.connection,cluster:this.cluster,userPublicKey:t.publicKey}):Promise.resolve(new Map)}static async fetchTokenRouteSegments(e,i,r){const a=await(async e=>await(await b.default(e)).json())(r||E[i]);return function(e){const t=new Map;return e.forEach((e=>{Ve(e.reserveTokenMints).forEach((([n,o])=>{!function(e,t,n,o){let i=o.get(e);i||(i=new Map([[t,[]]]),o.set(e,i));let r=i.get(t);r||(r=[],i.set(t,r)),r.push(n)}(Gt(n),Gt(o),e,t)}))})),t}(await async function(e,i){const r=(e=>e.map((e=>{const{data:[n,o],pubkey:i,...r}=e;return{...r,pubkey:new t.PublicKey(i),data:Buffer.from(n,o),owner:new t.PublicKey(r.owner)}})))(i),a=[];if(a.length){const t=await async function(e,t){const n=(await Ge(e,t.map((e=>e.toBase58())))).map(((e,n)=>{const o=t[n];if(!e)throw new Error(`Failed to fetch pool ${o.toBase58()}`);return{pubkey:o,...e}}));return n}(e,a);r.push(...t)}const s=r.reduce(((e,i)=>{const r=function(e,i,r){const a=new t.PublicKey(i.owner);if(a.equals(O)||a.equals(D)){const e=n.Market.getLayout(a).decode(i.data);if(!e.accountFlags.initialized||!e.accountFlags.market)throw new Error("Invalid market");const t=new n.Market(e,0,0,{},a);return new $e(t)}if(a.equals(L)){const t=new He(e,i,r);if(1===t.status)return t}else{if(a.equals(V))return new Mt(e,i,r);if(a.equals(o.SWAP_PROGRAM_ID)){const t=i.data.slice(2,3),n=o.StableSwap.loadWithData(e,i.data,re([e.toBuffer(),t],o.SWAP_PROGRAM_ID));if(n.state.isPaused||!n.state.isInitialized)return;return new ot(n)}if(a.equals(U))return new Tt(e,i);if(a.equals(R)||a.equals(q))return new lt(e,i,r);if([...pt.keys()].includes(a.toBase58())){var s;const t=null!==(s=pt.get(i.owner.toBase58()))&&void 0!==s?s:"Unknown";return new At(e,i,t)}if(a.equals(N))return new wt(e,i,r);if(a.equals(K)){const t=new bt(e,i);if(t.isPaused)return;return t}if(a.equals(C))return new Bt(e,i);if(a.equals(W))return new Ft(e,i);if(a.equals(G))return new Lt(e,i);if(a.equals(j))return new Ut(e,i)}}(i.pubkey,i,i.params);return r&&e.push(r),e}),new Array);return await(async(e,t)=>{const n=e.map((e=>e.getAccountsForUpdate().map((e=>e.toBase58())))).flat(),o=new Map;(await Ge(t,n)).forEach(((e,t)=>{e&&o.set(n[t],e)}));for(let t of e)t.update(o)})(s.filter((e=>e.shouldPrefetch)),e),s.push(...Ce()),s}(e,a))}getRouteMap(e){return function(e,t,n){const o=new Map;for(const[s,u]of e){const c=new Set;for(const[o,m]of u){var i;if(c.add(o),n)continue;const d=null!==(i=e.get(o))&&void 0!==i?i:new Map;for(const[n,i]of d){var r,a;if(n===s)continue;const d=null!==(r=null===(a=e.get(n))||void 0===a?void 0:a.size)&&void 0!==r?r:0;if(zt(t,Math.min(u.size,d),o))continue;let l=!1;for(const e of m){for(const t of i)if(nt(e,t)){c.add(n),l=!0;break}if(l)break}}}o.set(s,Array.from(c))}return o}(this.tokenRouteSegments,this.intermediateTokens,e)}static async getRemoteRouteMap({onlyDirectRoutes:e,restrictIntermediateTokens:t},n){let o=n||"https://cache.jup.ag/indexed-route-map";return e?o=o.concat("?onlyDirectRoutes=true"):t&&(o=o.concat("?restrictIntermediateTokens=true")),wn(await(await b.default(o)).json())}async executeInternal({wallet:e,onTransaction:t,inputMint:n,outputMint:o,sourceInstruction:i,setupInstructions:r,setupTransaction:a,swapTransaction:s,cleanupTransaction:u,owner:c,wrapUnwrapSOL:m}){let d,l;try{const g=[a,s,u].filter((e=>void 0!==e)),h=g.length;if(c.signer){const e=c.signer;g.forEach((t=>{t.sign(e)}))}else{if(!e)throw new Error("Signer wallet not found");if(h>1){const t=await e.signAllTransactions(g);let n=0;[a,s,u]=[a?t[n++]:void 0,t[n++],u?t[n++]:void 0]}else s=await e.signTransaction(s)}if(a){let e=mn(a);const n=(async()=>await yn(await cn(this.connection,a)))();if(null==t||t(e,h,"SETUP",n),await n instanceof Error)throw l}const f=mn(s);try{const e=(async()=>await yn(await cn(this.connection,s)))();null==t||t(f,h,"SWAP",e);const a=await e;if(a instanceof Error)throw a;const[d,g]=function({txid:e,inputMint:t,outputMint:n,user:o,sourceAddress:i,destinationAddress:r,transactionResponse:a,hasWrappedSOL:s}){let u,c;if(a){let{meta:e,transaction:m}=a;e&&(u=t.equals(F)&&!s?an(e,m,o):rn(e,m,i),c=n.equals(F)&&!s?an(e,m,o):rn(e,m,r))}if(!u||!c)throw new p.TransactionError("Cannot find source or destination token account balance change",e,$.BalancesNotExtractedProperly.code);return[u,c]}({txid:f,inputMint:n,outputMint:o,user:c.publicKey,sourceAddress:i.address,destinationAddress:r.destination.address,transactionResponse:a,hasWrappedSOL:Boolean(u)||!m});l={txid:f,inputAddress:i.address,outputAddress:r.destination.address,inputAmount:d,outputAmount:g}}catch(e){d=e}finally{if(u){const e=mn(u),n=(async()=>yn(await cn(this.connection,u)))();null==t||t(e,h,"CLEANUP",n),await n}}if(d||!l)throw d||new Error("Swap failed");return l}catch(e){return{error:e}}finally{this.routeCache.clear()}}static async getIntermediateTokens(){const e=await async function(){const e=await(await b.default("https://cache.jup.ag/top-tokens")).json();return new Set(e.filter(((e,t)=>t<60)))}();for(const t of J)e.add(t);return Ce().forEach((t=>{e.add(t.wrappedToken.addDecimals.mint.toBase58())})),Array.from(e)}}Pn.findSerumOpenOrdersForOwner=async({userPublicKey:e,cluster:t,connection:o})=>{const i=new Map;if(e){const r="mainnet-beta"===t?O:D;(await n.OpenOrders.findForOwner(o,e,r)).forEach((e=>{i.set(e.market.toString(),e.address)}))}return i},Pn.createInitializeTokenLedgerInstruction=function(e,n){return le.instruction.initializeTokenLedger({accounts:{tokenLedger:e,payer:n,systemProgram:t.SystemProgram.programId}})},Object.defineProperty(exports,"TransactionError",{enumerable:!0,get:function(){return p.TransactionError}}),exports.ALDRIN_SWAP_PROGRAM_ID=R,exports.ALDRIN_SWAP_V2_PROGRAM_ID=q,exports.AldrinAmm=lt,exports.CREMA_PROGRAM_ID=U,exports.CROPPER_PROGRAM_ID=N,exports.CYKURA_FACTORY_STATE_ADDRESS=z,exports.CYKURA_PROGRAM_ID=G,exports.CropperAmm=wt,exports.CykuraAmm=Lt,exports.DEVNET_SERUM_DEX_PROGRAM=D,exports.INDEXED_ROUTE_MAP_URL="https://cache.jup.ag/indexed-route-map",exports.IS_DEV=!1,exports.JUPITER_ERRORS=$,exports.JUPITER_WALLET=_,exports.Jupiter=Pn,exports.LAMPORTS_PER_SIGNATURE=5e3,exports.LIFINITY_PROGRAM_ID=C,exports.MAINNET_SERUM_DEX_PROGRAM=O,exports.MARINADE_PROGRAM_ID=j,exports.MARKETS_URL=E,exports.MERCURIAL_SWAP_PROGRAM_ID=V,exports.MIN_SEGMENT_SIZE_FOR_INTERMEDIATE_MINTS=100,exports.MercurialAmm=Mt,exports.ORCA_PROGRAM_ID=Z,exports.PENGUIN_PROGRAM_ID=Y,exports.RAYDIUM_AMM_V4_PROGRAM_ID=L,exports.RaydiumAmm=He,exports.SABER_ADD_DECIMALS_PROGRAM_ID=x,exports.SAROS_PROGRAM_ID=X,exports.SENCHA_PROGRAM_ID=K,exports.STEPN_PROGRAM_ID=Q,exports.STEP_TOKEN_SWAP_PROGRAM_ID=H,exports.SWAP_PROTOCOL_TOKENS=J,exports.SaberAddDecimalsAmm=_e,exports.SaberAmm=ot,exports.SenchaAmm=bt,exports.SerumAmm=$e,exports.SplTokenSwapAmm=At,exports.SplitTradeAmm=tt,exports.TOKEN_LIST_URL={devnet:"https://api.jup.ag/api/tokens/devnet",testnet:"https://api.jup.ag/api/markets/devnet","mainnet-beta":"https://cache.jup.ag/tokens"},exports.TransactionBuilder=tn,exports.WHIRLPOOL_PROGRAM_ID=W,exports.WRAPPED_SOL_MINT=F,exports.WhirlpoolAmm=Ft,exports.getEmptyInstruction=()=>({instructions:[],cleanupInstructions:[],signers:[]}),exports.getPlatformFeeAccounts=en,exports.getRouteInfoUniqueId=function(e){return e.marketInfos.map((e=>`${e.amm.id}-${e.inputMint}`)).join("-")},exports.getSaberWrappedDecimalsAmms=Ce,exports.indexedRouteMapToRouteMap=wn,exports.routeMapToIndexedRouteMap=function(e){const{mintToIndexMap:t,indexedRouteMap:n}=Array.from(e).reduce((({mintToIndexMap:e,indexedRouteMap:t},[n,o])=>{const i=Mn(n,e),r=[];for(const t of o){const n=Mn(t,e);r.push(n)}return t[i]=r,{mintToIndexMap:e,indexedRouteMap:t}}),{mintToIndexMap:new Map,indexedRouteMap:{}});return{mintKeys:[...t.keys()],indexedRouteMap:n}},exports.transactionSenderAndConfirmationWaiter=cn;
//# sourceMappingURL=core.cjs.production.min.js.map
